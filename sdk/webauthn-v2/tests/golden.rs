use serde::Deserialize;
use std::collections::HashMap;
use webauthn_v2::digest;
use webauthn_v2::merkle::{keccak256, MerkleTree};

/// Golden vectors generated by `forge script script/GenerateGoldenVectors.s.sol`
/// Source of truth: Solidity contract (WebAuthnValidatorV2 + WebAuthnRecoveryBase)
const GOLDEN_PATH: &str = "../../test/WebAuthnValidator/fixtures/golden-vectors.json";

// ── JSON schema matching the Forge-generated golden-vectors.json ──

#[derive(Deserialize)]
struct GoldenVectors {
    chain_id: u64,
    validator_address: String,
    typehashes: Typehashes,
    passkey_digest: HashMap<String, DigestVector>,
    passkey_multichain: HashMap<String, DigestVector>,
    recovery_digest: RecoveryVector,
    merkle: MerkleVector,
}

#[derive(Deserialize)]
struct Typehashes {
    passkey_digest: String,
    passkey_multichain: String,
    recover_passkey: String,
}

#[derive(Deserialize)]
struct DigestVector {
    input: String,
    output: String,
}

#[derive(Deserialize)]
struct RecoveryVector {
    account: String,
    chain_id: u64,
    new_key_id: u64,
    new_pub_key_x: String, // decimal from vm.serializeUint
    new_pub_key_y: String, // decimal from vm.serializeUint
    nonce: u64,
    expiry: u64,
    output: String,
}

#[derive(Deserialize)]
struct MerkleVector {
    leaves: HashMap<String, String>,
    root: String,
    proof_0: HashMap<String, String>,
    proof_1: HashMap<String, String>,
    proof_2: HashMap<String, String>,
}

// ── Helpers ──

fn load_golden() -> GoldenVectors {
    let content = std::fs::read_to_string(GOLDEN_PATH).unwrap_or_else(|e| {
        panic!(
            "Failed to read golden vectors at {GOLDEN_PATH}: {e}\n\
             Run: forge script script/GenerateGoldenVectors.s.sol -vvv"
        )
    });
    serde_json::from_str(&content).expect("Failed to parse golden vectors JSON")
}

fn parse_bytes32(hex_str: &str) -> [u8; 32] {
    let s = hex_str.strip_prefix("0x").unwrap_or(hex_str);
    let bytes = hex::decode(s).unwrap();
    let mut arr = [0u8; 32];
    arr.copy_from_slice(&bytes);
    arr
}

fn parse_address20(hex_str: &str) -> [u8; 20] {
    let s = hex_str.strip_prefix("0x").unwrap_or(hex_str);
    let bytes = hex::decode(s).unwrap();
    let mut arr = [0u8; 20];
    arr.copy_from_slice(&bytes);
    arr
}

fn to_hex(bytes: &[u8; 32]) -> String {
    format!("0x{}", hex::encode(bytes))
}

/// Convert decimal string to 0x-prefixed hex string (32 bytes, left-padded).
fn decimal_to_hex_u256(decimal: &str) -> String {
    let n: num_bigint::BigUint = decimal.parse().expect("invalid decimal");
    let bytes = n.to_bytes_be();
    let mut word = [0u8; 32];
    word[32 - bytes.len()..].copy_from_slice(&bytes);
    format!("0x{}", hex::encode(word))
}

/// Get sorted proof elements from a HashMap<String, String> keyed by "0", "1", ...
fn sorted_proof(map: &HashMap<String, String>) -> Vec<[u8; 32]> {
    let mut keys: Vec<usize> = map.keys().map(|k| k.parse().unwrap()).collect();
    keys.sort();
    keys.iter().map(|k| parse_bytes32(&map[&k.to_string()])).collect()
}

// ── Tests ──

#[test]
fn golden_typehashes() {
    let v = load_golden();

    assert_eq!(
        to_hex(&digest::passkey_digest_typehash()),
        v.typehashes.passkey_digest,
        "PASSKEY_DIGEST_TYPEHASH mismatch"
    );

    assert_eq!(
        to_hex(&digest::passkey_multichain_typehash()),
        v.typehashes.passkey_multichain,
        "PASSKEY_MULTICHAIN_TYPEHASH mismatch"
    );

    assert_eq!(
        to_hex(&digest::recover_passkey_typehash()),
        v.typehashes.recover_passkey,
        "RECOVER_PASSKEY_TYPEHASH mismatch"
    );
}

#[test]
fn golden_passkey_digest() {
    let v = load_golden();
    let contract = parse_address20(&v.validator_address);

    for (_, vector) in &v.passkey_digest {
        let input = parse_bytes32(&vector.input);
        let result = digest::passkey_digest(&input, v.chain_id, &contract);
        assert_eq!(
            to_hex(&result),
            vector.output.to_lowercase(),
            "passkey_digest mismatch for input {}",
            vector.input
        );
    }
}

#[test]
fn golden_passkey_multichain() {
    let v = load_golden();

    let contract = parse_address20(&v.validator_address);

    for (_, vector) in &v.passkey_multichain {
        let input = parse_bytes32(&vector.input);
        let result = digest::passkey_multichain(&input, &contract);
        assert_eq!(
            to_hex(&result),
            vector.output.to_lowercase(),
            "passkey_multichain mismatch for input {}",
            vector.input
        );
    }
}

#[test]
fn golden_recovery_digest() {
    let v = load_golden();
    let r = &v.recovery_digest;

    let input = digest::RecoveryDigestInput {
        account: r.account.clone(),
        chain_id: r.chain_id,
        new_key_id: r.new_key_id as u16,
        new_pub_key_x: decimal_to_hex_u256(&r.new_pub_key_x),
        new_pub_key_y: decimal_to_hex_u256(&r.new_pub_key_y),
        replace: false,
        nonce: decimal_to_hex_u256(&r.nonce.to_string()),
        expiry: r.expiry,
        verifying_contract: v.validator_address.clone(),
    };

    let result = digest::recovery_digest(&input).unwrap();
    assert_eq!(
        to_hex(&result),
        r.output.to_lowercase(),
        "recovery_digest mismatch"
    );
}

#[test]
fn golden_merkle_tree() {
    let v = load_golden();
    let m = &v.merkle;

    // Reconstruct leaves in order
    let leaves: Vec<[u8; 32]> = (0..3)
        .map(|i| parse_bytes32(&m.leaves[&i.to_string()]))
        .collect();

    // Verify leaves match keccak256 of sequential bytes (same as Forge script)
    for i in 0..3u8 {
        assert_eq!(
            leaves[i as usize],
            keccak256(&[i]),
            "leaf {i} doesn't match keccak256([{i}])"
        );
    }

    // Build tree and compare root
    let tree = MerkleTree::new(leaves.clone());
    let (root, proofs) = tree.build().unwrap();
    assert_eq!(
        to_hex(&root),
        m.root.to_lowercase(),
        "merkle root mismatch"
    );

    // Compare proofs
    let golden_proofs = [
        sorted_proof(&m.proof_0),
        sorted_proof(&m.proof_1),
        sorted_proof(&m.proof_2),
    ];

    for (i, (rust_proof, golden_proof)) in proofs.iter().zip(golden_proofs.iter()).enumerate() {
        assert_eq!(
            rust_proof.len(),
            golden_proof.len(),
            "proof length mismatch for leaf {i}"
        );
        for (j, (r, g)) in rust_proof.iter().zip(golden_proof.iter()).enumerate() {
            assert_eq!(r, g, "proof element [{i}][{j}] mismatch");
        }
    }

    // Verify each proof against root (cross-check)
    for (i, leaf) in leaves.iter().enumerate() {
        assert!(
            MerkleTree::verify(&golden_proofs[i], &root, leaf),
            "merkle proof verification failed for leaf {i}"
        );
    }
}
