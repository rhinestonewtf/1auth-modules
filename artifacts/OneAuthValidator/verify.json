{"language":"Solidity","sources":{"src/OneAuth/OneAuthValidator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nimport { ERC7579HybridValidatorBase } from \"modulekit/Modules.sol\";\nimport { PackedUserOperation } from \"modulekit/external/ERC4337.sol\";\nimport { MerkleProofLib } from \"solady/utils/MerkleProofLib.sol\";\nimport { EnumerableSetLib } from \"solady/utils/EnumerableSetLib.sol\";\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\nimport { WebAuthn } from \"solady/utils/WebAuthn.sol\";\nimport {\n    MODULE_TYPE_STATELESS_VALIDATOR as TYPE_STATELESS_VALIDATOR\n} from \"modulekit/module-bases/utils/ERC7579Constants.sol\";\nimport { OneAuthRecoveryBase } from \"./OneAuthRecoveryBase.sol\";\nimport { IOneAuthValidator } from \"./IOneAuthValidator.sol\";\nimport { EIP712Lib } from \"./lib/EIP712Lib.sol\";\nimport { P256Lib } from \"./lib/P256Lib.sol\";\nimport { MAX_MERKLE_DEPTH, MAX_CREDENTIALS } from \"./lib/Constants.sol\";\n\n/**\n * @title OneAuthValidator\n * @notice ERC-7579 WebAuthn passkey validator module with merkle tree batch signing support\n * @dev The user signs a merkle root (tree of operation digests) with their passkey.\n *      Each operation provides a merkle proof showing its digest is a leaf in the tree.\n *      When proofLength = 0, falls back to regular signing (user signs digest directly).\n *      Supports multiple passkeys via 2-byte keyIds; any single credential can sign.\n *\n *      KNOWN SECURITY CONSIDERATIONS:\n *\n *      Recovery supports in-place rotation: When replace is true in the recovery struct,\n *      the credential at keyId has its public key overwritten in-place. When replace is\n *      false, recovery is additive (new credential added, existing keys remain).\n *\n *      Cross-chain merkle signing requires same contract address: _passkeyMultichain() uses\n *      _hashTypedDataSansChainId which omits chainId but still includes verifyingContract in\n *      the EIP-712 domain separator. The module must be deployed at the same address on all\n *      target chains (e.g., via CREATE2) for cross-chain signatures to verify.\n */\ncontract OneAuthValidator is ERC7579HybridValidatorBase, OneAuthRecoveryBase, IOneAuthValidator {\n    using EnumerableSetLib for EnumerableSetLib.Uint256Set;\n    using EfficientHashLib for bytes32;\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Stores the P-256 public key coordinates for a single WebAuthn credential\n     * @param pubKeyX X coordinate of the P-256 (secp256r1) public key\n     * @param pubKeyY Y coordinate of the P-256 (secp256r1) public key\n     */\n    struct WebAuthnCredential {\n        bytes32 pubKeyX;\n        bytes32 pubKeyY;\n    }\n\n    /**\n     * @notice Per-account credential storage: a mapping from credKey to credential plus\n     *         an enumerable set of active credKeys for iteration during uninstall\n     * @dev credKey = uint256(keyId). The enumerable set enables iterating all credentials\n     *      during onUninstall cleanup and provides O(1) membership checks for add/remove\n     *      operations.\n     */\n    struct PasskeyCredentials {\n        mapping(uint256 credKey => WebAuthnCredential) credentials;\n        EnumerableSetLib.Uint256Set enabledCredKeys;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Passkey credentials per account\n    /// @dev credKey = uint256(keyId)\n    mapping(address account => PasskeyCredentials) internal _passkeyCredentials;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONFIG\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Install the module with initial credentials and optional guardian config\n     * @dev Called by the smart account during module installation (ERC-7579 lifecycle).\n     *      msg.sender is the smart account itself, not an EOA or external caller.\n     * @param data abi.encode(uint16[] keyIds, WebAuthnCredential[] creds, address userGuardian, address externalGuardian, uint8 guardianThreshold)\n     */\n    function onInstall(bytes calldata data) external override {\n        address account = msg.sender;\n        if (isInitialized(account)) revert ModuleAlreadyInitialized(account);\n\n        (\n            uint16[] memory keyIds,\n            WebAuthnCredential[] memory creds,\n            address _userGuardian,\n            address _externalGuardian,\n            uint8 _guardianThreshold\n        ) = abi.decode(data, (uint16[], WebAuthnCredential[], address, address, uint8));\n        uint256 length = creds.length;\n\n        if (length == 0 || length != keyIds.length) {\n            revert InvalidPublicKey();\n        }\n        if (length > MAX_CREDENTIALS) revert TooManyCredentials();\n\n        PasskeyCredentials storage pc = _passkeyCredentials[account];\n        for (uint256 i; i < length; ++i) {\n            _storeCredential(pc, account, keyIds[i], creds[i].pubKeyX, creds[i].pubKeyY);\n        }\n\n        // Set guardian config if any guardian is provided or threshold is explicitly set\n        if (_userGuardian != address(0) || _externalGuardian != address(0) || _guardianThreshold != 0)\n        {\n            // Default threshold to 1 when guardians provided but no explicit threshold\n            uint8 effectiveThreshold = _guardianThreshold == 0 ? 1 : _guardianThreshold;\n            _setGuardianConfigImmediate(\n                account, _userGuardian, _externalGuardian, effectiveThreshold\n            );\n        }\n\n        emit ModuleInitialized(account);\n    }\n\n    /**\n     * @notice Uninstall the module, clearing all credentials and guardian\n     * @dev Called by the smart account during module removal (ERC-7579 lifecycle).\n     *      msg.sender is the smart account. Iterates all enabled credKeys, deletes each\n     *      credential's public key data, removes it from the enumerable set, and clears\n     *      the guardian address.\n     *      NOTE: Used recovery nonces (in _recoveryConfig[account].nonceUsed) are intentionally\n     *      NOT cleared. This prevents replay attacks where a previously-used recovery signature\n     *      could be replayed after reinstalling the module.\n     */\n    function onUninstall(bytes calldata) external override {\n        // msg.sender is the smart account (ERC-7579 lifecycle)\n        address account = msg.sender;\n        PasskeyCredentials storage pc = _passkeyCredentials[account];\n\n        // Snapshot all credKeys into memory before mutating the set\n        uint256[] memory credKeys = pc.enabledCredKeys.values();\n\n        // Delete each credential's public key and remove from the enumerable set\n        for (uint256 i; i < credKeys.length; ++i) {\n            delete pc.credentials[credKeys[i]];\n            pc.enabledCredKeys.remove(credKeys[i]);\n        }\n\n        // Clear guardian state but leave nonceUsed intact to prevent replay after reinstallation\n        delete _recoveryConfig[account].guardian;\n\n        emit ModuleUninitialized(account);\n    }\n\n    /**\n     * @notice Check whether the module is installed for a given smart account\n     * @dev An account is considered initialized if it has at least one credential registered.\n     *      Since onInstall requires at least one credential and removeCredential prevents\n     *      removing the last one, a zero count means never installed or fully uninstalled.\n     * @param smartAccount The smart account address to check\n     * @return True if the account has at least one registered credential\n     */\n    function isInitialized(address smartAccount) public view returns (bool) {\n        return _passkeyCredentials[smartAccount].enabledCredKeys.length() > 0;\n    }\n\n    /**\n     * @notice Get the number of credentials for an account\n     * @param account The smart account address\n     * @return The count of currently registered credentials\n     */\n    function credentialCount(address account) external view returns (uint256) {\n        return _passkeyCredentials[account].enabledCredKeys.length();\n    }\n\n    /**\n     * @notice Get all enabled credential keys for an account\n     * @dev Each credKey is uint256(keyId).\n     * @param account The smart account address\n     * @return Array of credKey values\n     */\n    function getCredKeys(address account) external view returns (uint256[] memory) {\n        return _passkeyCredentials[account].enabledCredKeys.values();\n    }\n\n    /**\n     * @notice Add a new credential with a specific keyId\n     * @dev msg.sender is the smart account calling this function directly (not via entrypoint).\n     *      The module must already be installed (isInitialized check in _addCredential), preventing\n     *      credentials from being added before onInstall establishes the account's credential set.\n     * @param keyId 16-bit identifier for this credential\n     * @param pubKeyX X coordinate of the P-256 public key (validated to be on curve)\n     * @param pubKeyY Y coordinate of the P-256 public key (validated to be on curve)\n     */\n    function addCredential(uint16 keyId, bytes32 pubKeyX, bytes32 pubKeyY) external {\n        // msg.sender is the smart account calling directly\n        _addCredential(msg.sender, keyId, pubKeyX, pubKeyY);\n    }\n\n    /**\n     * @notice Remove a credential by keyId\n     * @dev msg.sender is the smart account calling this function directly. Prevents removing\n     *      the last credential to maintain a liveness guarantee -- the account must always\n     *      have at least one credential capable of signing to avoid permanent lockout.\n     * @param keyId 16-bit identifier of the credential to remove\n     */\n    function removeCredential(uint16 keyId) external {\n        // msg.sender is the smart account calling directly\n        address account = msg.sender;\n        PasskeyCredentials storage pc = _passkeyCredentials[account];\n        uint256 len = pc.enabledCredKeys.length();\n\n        // Must be initialized (has at least one credential)\n        if (len == 0) revert NotInitialized(account);\n\n        // Prevent removing the last credential -- the account would be permanently locked\n        // since there would be no valid signer to authorize operations or add new credentials\n        if (len <= 1) revert CannotRemoveLastCredential();\n\n        uint256 ck = uint256(keyId);\n\n        // EnumerableSetLib.remove returns false if the key was not in the set\n        if (!pc.enabledCredKeys.remove(ck)) revert CredentialNotFound(keyId);\n        delete pc.credentials[ck];\n        emit CredentialRemoved(account, keyId);\n    }\n\n    /**\n     * @notice Get the P-256 public key coordinates for a specific credential\n     * @dev Returns (0, 0) if the credential does not exist.\n     * @param keyId 16-bit identifier of the credential\n     * @param account The smart account address that owns the credential\n     * @return pubKeyX X coordinate of the P-256 public key (bytes32(0) if not found)\n     * @return pubKeyY Y coordinate of the P-256 public key (bytes32(0) if not found)\n     */\n    function getCredential(\n        uint16 keyId,\n        address account\n    )\n        external\n        view\n        returns (bytes32 pubKeyX, bytes32 pubKeyY)\n    {\n        uint256 ck = uint256(keyId);\n        WebAuthnCredential storage cred = _passkeyCredentials[account].credentials[ck];\n        return (cred.pubKeyX, cred.pubKeyY);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                VALIDATE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice ERC-4337 user operation validation (called by the EntryPoint)\n     * @dev The account address is userOp.sender, NOT msg.sender (msg.sender is the EntryPoint).\n     *      Returns VALIDATION_SUCCESS (0) if the signature is valid, or VALIDATION_FAILED (1)\n     *      otherwise. Must never revert per ERC-4337 spec -- all failure cases return\n     *      VALIDATION_FAILED instead.\n     * @param userOp The packed user operation containing the signature in userOp.signature\n     * @param userOpHash The hash of the user operation (used as the digest to verify)\n     * @return ValidationData VALIDATION_SUCCESS (0) or VALIDATION_FAILED (1)\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        view\n        override\n        returns (ValidationData)\n    {\n        // account is userOp.sender (the smart account), not msg.sender (the EntryPoint)\n        if (_validateSignatureWithConfig(userOp.sender, userOpHash, userOp.signature)) {\n            return VALIDATION_SUCCESS;\n        }\n        return VALIDATION_FAILED;\n    }\n\n    /**\n     * @notice EIP-1271 signature validation (called by the smart account)\n     * @dev The first parameter (sender) is intentionally ignored. Per ERC-7579, the smart\n     *      account calls this function on the validator module, so msg.sender IS the smart\n     *      account and is used as the account for credential lookup. The sender parameter\n     *      (which would be the original caller of the smart account's isValidSignature)\n     *      is not relevant for credential-based validation.\n     * @param hash The hash of the data to validate\n     * @param data The packed signature data (same format as userOp.signature)\n     * @return bytes4 EIP1271_SUCCESS (0x1626ba7e) if valid, EIP1271_FAILED (0xffffffff) otherwise\n     */\n    function isValidSignatureWithSender(\n        address, /* sender -- ignored; msg.sender (the smart account) is the relevant account */\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        returns (bytes4)\n    {\n        // msg.sender is the smart account (ERC-7579: the account calls this on the validator)\n        if (_validateSignatureWithConfig(msg.sender, hash, data)) {\n            return EIP1271_SUCCESS;\n        }\n        return EIP1271_FAILED;\n    }\n\n    /**\n     * @notice ERC-7579 stateless validation extension -- credentials are provided externally\n     *         in `data` rather than fetched from on-chain storage\n     * @dev Unlike the stateful validateUserOp / isValidSignatureWithSender paths, this function\n     *      does not look up credentials by account. Instead, the caller provides the public key\n     *      and validation parameters in `data`, and the WebAuthn signature in `signature`.\n     *      This enables off-chain verifiers to validate signatures without the module being installed.\n     *\n     *      NOTE: Unlike the stateful validation paths (validateUserOp, isValidSignatureWithSender)\n     *      which return false/VALIDATION_FAILED on invalid input per ERC-4337, this function REVERTS\n     *      on malformed input (InvalidSignatureData, ProofTooLong, InvalidMerkleProof). It only\n     *      returns false for valid-format-but-wrong-signature cases (when WebAuthn.verify fails).\n     *\n     *      The `data` layout mirrors the stateful signature format (proof before credential data):\n     *        [0]       proofLength (uint8)\n     *        if proofLength == 0 (regular signing, challenge = _passkeyDigest(hash)):\n     *          [1:33]                         pubKeyX\n     *          [33:65]                        pubKeyY\n     *        if proofLength > 0 (merkle proof, challenge = _passkeyMultichain(merkleRoot)):\n     *          [1:33]                         merkleRoot (bytes32)\n     *          [33:33+proofLength*32]         proof (bytes32[])\n     *          [proofEnd:proofEnd+32]         pubKeyX\n     *          [proofEnd+32:proofEnd+64]      pubKeyY\n     *      `signature` is packed WebAuthnAuth (see P256Lib.parseWebAuthnAuth for format).\n     * @param hash The digest to validate (or a leaf in the merkle tree for batch signing)\n     * @param signature Packed WebAuthnAuth struct (r, s, challengeIndex, typeIndex, authenticatorData, clientDataJSON)\n     * @param data Packed credential and proof data as described above\n     * @return True if the signature is valid for the provided credentials\n     */\n    function validateSignatureWithData(\n        bytes32 hash,\n        bytes calldata signature,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (data.length < 1) revert InvalidSignatureData();\n        uint256 proofLength = uint8(data[0]);\n\n        // Regular path: proofLength == 0 means no merkle proof, challenge is chain-specific\n        if (proofLength == 0) {\n            // Minimum data: 1 (proofLength) + 32 (pubKeyX) + 32 (pubKeyY) = 65\n            if (data.length < 65) revert InvalidSignatureData();\n            (WebAuthn.WebAuthnAuth memory auth, bool ok) = P256Lib.parseWebAuthnAuth(signature);\n            if (!ok) revert InvalidSignatureData();\n\n            // Challenge is _passkeyDigest(hash): chain-specific EIP-712 typed data\n            return WebAuthn.verify(\n                abi.encode(_passkeyDigest(hash)),\n                true, // requireUV: always enforce user verification\n                auth,\n                bytes32(data[1:33]), // pubKeyX\n                bytes32(data[33:65]) // pubKeyY\n            );\n        }\n\n        // Merkle proof path: challenge = _passkeyMultichain(merkleRoot) (chain-agnostic)\n        if (proofLength > MAX_MERKLE_DEPTH) revert ProofTooLong();\n\n        // proofEnd marks where the proof bytes end and credential data begins\n        uint256 proofEnd = 33 + (proofLength << 5); // 33 + proofLength * 32\n        // Minimum remaining data: pubKeyX (32) + pubKeyY (32) = 64\n        if (data.length < proofEnd + 64) revert InvalidSignatureData();\n\n        bytes32 merkleRoot = bytes32(data[1:33]);\n\n        {\n            // Assembly constructs a calldata slice pointing to the proof bytes32[] array.\n            // This avoids copying the proof to memory -- MerkleProofLib.verifyCalldata reads\n            // directly from calldata.\n            bytes32[] calldata proof;\n            /// @solidity memory-safe-assembly\n            assembly {\n                proof.offset := add(data.offset, 33)\n                proof.length := proofLength\n            }\n            // Verify that `hash` (the operation digest) is a leaf in the merkle tree\n            if (!MerkleProofLib.verifyCalldata(proof, merkleRoot, hash)) {\n                revert InvalidMerkleProof();\n            }\n        }\n\n        {\n            (WebAuthn.WebAuthnAuth memory auth, bool ok) = P256Lib.parseWebAuthnAuth(signature);\n            if (!ok) revert InvalidSignatureData();\n\n            // Challenge is _passkeyMultichain(merkleRoot): chain-agnostic EIP-712 hash of the\n            // merkle root, enabling a single passkey signature to cover multiple operations\n            // across multiple chains\n            return WebAuthn.verify(\n                abi.encode(_passkeyMultichain(merkleRoot)),\n                true, // requireUV: always enforce user verification\n                auth,\n                bytes32(data[proofEnd:proofEnd + 32]), // pubKeyX\n                bytes32(data[proofEnd + 32:proofEnd + 64]) // pubKeyY\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           RECOVERY HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Hook called by OneAuthRecoveryBase during recovery (recoverWithPasskey or\n     *      recoverWithGuardian). When replace is false, delegates to _addCredential\n     *      (additive). When replace is true, overwrites the existing credential at\n     *      keyId in-place with the new public key (rotation).\n     * @param account The smart account to add/replace the credential on\n     * @param cred The new credential parameters (keyId, pubKeyX, pubKeyY, replace)\n     */\n    function _addCredentialRecovery(\n        address account,\n        NewCredential calldata cred\n    )\n        internal\n        override\n    {\n        if (cred.replace) {\n            _replaceCredential(account, cred.keyId, cred.pubKeyX, cred.pubKeyY);\n        } else {\n            _addCredential(account, cred.keyId, cred.pubKeyX, cred.pubKeyY);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Chain-specific EIP-712 challenge for single operation signing\n     * @dev Uses Solady's _hashTypedData which includes chainId in the EIP-712 domain separator.\n     *      This prevents cross-chain replay: a signature made on chain A cannot be reused on\n     *      chain B. The domain also includes verifyingContract (this module's address), which\n     *      prevents cross-contract replay.\n     * @param digest The operation digest to wrap in the EIP-712 typed data envelope\n     * @return The chain-specific EIP-712 hash to be used as the WebAuthn challenge\n     */\n    function _passkeyDigest(bytes32 digest) internal view returns (bytes32) {\n        return _hashTypedData(EIP712Lib.PASSKEY_DIGEST_TYPEHASH.hash(digest));\n    }\n\n    /**\n     * @notice Chain-agnostic EIP-712 challenge for merkle batch signing\n     * @dev Uses Solady's _hashTypedDataSansChainId which omits chainId from the EIP-712 domain\n     *      separator, enabling a single passkey signature over the merkle root to validate on\n     *      multiple chains. The domain still includes verifyingContract, so the module must be\n     *      deployed at the same address on all target chains (e.g., via CREATE2).\n     * @param root The merkle root covering multiple operation digests across chains\n     * @return The chain-agnostic EIP-712 hash to be used as the WebAuthn challenge\n     */\n    function _passkeyMultichain(bytes32 root) internal view returns (bytes32) {\n        return _hashTypedDataSansChainId(EIP712Lib.PASSKEY_MULTICHAIN_TYPEHASH.hash(root));\n    }\n\n    /**\n     * @notice Compute the passkey challenge for a single operation digest (chain-specific)\n     * @dev Public convenience wrapper around _passkeyDigest for off-chain tooling to compute\n     *      the exact challenge bytes the passkey must sign for regular (non-merkle) operations.\n     * @param digest The operation digest (e.g., userOpHash)\n     * @return The EIP-712 typed data hash to be used as the WebAuthn challenge\n     */\n    function getPasskeyDigest(bytes32 digest) public view returns (bytes32) {\n        return _passkeyDigest(digest);\n    }\n\n    /**\n     * @notice Compute the passkey challenge for a merkle root (chain-agnostic)\n     * @dev Public convenience wrapper around _passkeyMultichain for off-chain tooling to\n     *      compute the exact challenge bytes the passkey must sign for merkle batch operations.\n     * @param root The merkle root of the operation digest tree\n     * @return The chain-agnostic EIP-712 typed data hash to be used as the WebAuthn challenge\n     */\n    function getPasskeyMultichain(bytes32 root) public view returns (bytes32) {\n        return _passkeyMultichain(root);\n    }\n\n    /**\n     * @notice Add a credential to an initialized account with capacity checks\n     * @dev Shared by addCredential() (user-initiated) and _addCredentialRecovery()\n     *      (recovery-initiated). Validates initialization and capacity, then delegates\n     *      to _storeCredential for the per-credential work.\n     */\n    function _addCredential(\n        address account,\n        uint16 keyId,\n        bytes32 pubKeyX,\n        bytes32 pubKeyY\n    )\n        internal\n    {\n        PasskeyCredentials storage pc = _passkeyCredentials[account];\n        uint256 len = pc.enabledCredKeys.length();\n\n        // Cannot add credentials before the module is installed via onInstall\n        if (len == 0) revert NotInitialized(account);\n\n        // Enforce the credential cap to bound gas costs during onUninstall iteration\n        if (len >= MAX_CREDENTIALS) revert TooManyCredentials();\n\n        _storeCredential(pc, account, keyId, pubKeyX, pubKeyY);\n    }\n\n    /**\n     * @notice Validate and store a single credential\n     * @dev Shared by onInstall (batch) and _addCredential (single). Validates the public key\n     *      is on the P-256 curve, rejects duplicate keyIds, writes storage, and emits event.\n     *      Callers are responsible for initialization and capacity checks.\n     */\n    function _storeCredential(\n        PasskeyCredentials storage pc,\n        address account,\n        uint16 keyId,\n        bytes32 pubKeyX,\n        bytes32 pubKeyY\n    )\n        internal\n    {\n        if (!P256Lib.isOnCurve(uint256(pubKeyX), uint256(pubKeyY))) revert InvalidPublicKey();\n        uint256 ck = uint256(keyId);\n        if (!pc.enabledCredKeys.add(ck)) revert KeyIdAlreadyExists(keyId);\n        pc.credentials[ck] = WebAuthnCredential(pubKeyX, pubKeyY);\n        emit CredentialAdded(account, keyId, pubKeyX, pubKeyY);\n    }\n\n    /**\n     * @notice In-place rotation of an existing credential's public key\n     * @dev Used by recovery to overwrite a compromised key. The credential at keyId must\n     *      already exist; its public key is replaced with the new one.\n     */\n    function _replaceCredential(\n        address account,\n        uint16 keyId,\n        bytes32 pubKeyX,\n        bytes32 pubKeyY\n    )\n        internal\n    {\n        PasskeyCredentials storage pc = _passkeyCredentials[account];\n        uint256 len = pc.enabledCredKeys.length();\n\n        if (len == 0) revert NotInitialized(account);\n        if (!P256Lib.isOnCurve(uint256(pubKeyX), uint256(pubKeyY))) revert InvalidPublicKey();\n\n        uint256 ck = uint256(keyId);\n        if (!pc.enabledCredKeys.contains(ck)) revert CredentialNotFound(keyId);\n\n        pc.credentials[ck] = WebAuthnCredential(pubKeyX, pubKeyY);\n\n        emit CredentialRemoved(account, keyId);\n        emit CredentialAdded(account, keyId, pubKeyX, pubKeyY);\n    }\n\n    /**\n     * @notice Core stateful validation -- router that dispatches to regular or merkle path\n     * @dev Returns false (not revert) for all failure cases. This is required by ERC-4337:\n     *      validateUserOp must not revert on invalid signatures, it must return VALIDATION_FAILED.\n     *      The same return-false-on-failure convention is used throughout the validation chain.\n     *\n     *      Packed signature format:\n     *        [0]                            proofLength (uint8)\n     *        if proofLength == 0 (regular signing, challenge = digest):\n     *          [1:3]                        keyId (uint16)\n     *          [3:]                         packed WebAuthnAuth\n     *        if proofLength > 0 (merkle proof, challenge = merkleRoot):\n     *          [1:33]                       merkleRoot (bytes32)\n     *          [33:33+proofLength*32]       proof\n     *          [proofEnd:proofEnd+2]        keyId (uint16)\n     *          [proofEnd+2:]                packed WebAuthnAuth\n     * @param account The smart account address (for credential lookup)\n     * @param digest The hash to validate (userOpHash or EIP-1271 hash)\n     * @param data The packed signature data\n     * @return True if the signature is valid\n     */\n    function _validateSignatureWithConfig(\n        address account,\n        bytes32 digest,\n        bytes calldata data\n    )\n        internal\n        view\n        override\n        returns (bool)\n    {\n        // Minimum 3 bytes: 1 (proofLength) + 2 (keyId)\n        if (data.length < 3) return false;\n\n        uint256 proofLength = uint8(data[0]);\n\n        // Dispatch: proofLength == 0 is regular signing, proofLength > 0 is merkle batch signing\n        if (proofLength == 0) {\n            return _validateRegular(account, digest, data);\n        }\n\n        return _validateMerkle(account, digest, data, proofLength);\n    }\n\n    /**\n     * @notice Regular signing path (proofLength=0): challenge = chain-specific EIP-712 digest\n     * @dev Extracts keyId from the packed signature header, looks up the credential by credKey,\n     *      parses the WebAuthnAuth from the remaining calldata, and delegates to WebAuthn.verify.\n     * @param account The smart account address for credential lookup\n     * @param digest The hash to validate (wrapped in _passkeyDigest for chain-specific EIP-712)\n     * @param data The full packed signature data (proofLength byte already consumed by caller)\n     * @return True if the WebAuthn signature is valid for the stored credential\n     */\n    function _validateRegular(\n        address account,\n        bytes32 digest,\n        bytes calldata data\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Extract the keyId from the packed calldata header\n        uint16 keyId = uint16(bytes2(data[1:3]));\n\n        // Look up the credential by keyId — loaded into memory for cheaper repeated access\n        uint256 ck = uint256(keyId);\n        WebAuthnCredential memory cred = _passkeyCredentials[account].credentials[ck];\n\n        // pubKeyX == 0 means this credential slot is empty (never registered or was deleted).\n        // Valid P-256 keys cannot have x=0 since that fails the P256Lib.isOnCurve check at registration.\n        if (cred.pubKeyX == bytes32(0)) return false;\n\n        // Parse the packed WebAuthnAuth from the remaining calldata after the 3-byte header\n        (WebAuthn.WebAuthnAuth memory auth, bool ok) = P256Lib.parseWebAuthnAuth(data[3:]);\n        if (!ok) return false;\n\n        // Challenge is chain-specific: _passkeyDigest wraps digest in EIP-712 with chainId\n        return WebAuthn.verify(\n            abi.encode(_passkeyDigest(digest)), true, auth, cred.pubKeyX, cred.pubKeyY\n        );\n    }\n\n    /**\n     * @notice Merkle signing path (proofLength>0): challenge = chain-agnostic EIP-712 hash of merkleRoot\n     * @dev Verifies that `digest` is a leaf in the merkle tree rooted at `merkleRoot`, then\n     *      validates the WebAuthn signature against the chain-agnostic challenge derived from\n     *      the merkle root. This allows a single passkey signature to authorize multiple\n     *      operations across multiple chains.\n     * @param account The smart account address for credential lookup\n     * @param digest The operation digest that should be a leaf in the merkle tree\n     * @param data The full packed signature data including merkle proof and credential header\n     * @param proofLength Number of 32-byte proof elements (already extracted from data[0])\n     * @return True if the merkle proof verifies AND the WebAuthn signature is valid\n     */\n    function _validateMerkle(\n        address account,\n        bytes32 digest,\n        bytes calldata data,\n        uint256 proofLength\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Bounds-check the proof depth to prevent DoS via oversized proofs that would\n        // consume excessive gas in the MerkleProofLib verification loop\n        if (proofLength > MAX_MERKLE_DEPTH) return false;\n\n        // Compute where the proof bytes end: 1 (proofLength) + 32 (merkleRoot) + proofLength * 32\n        // Using left shift by 5 as an optimization for multiplication by 32\n        uint256 proofEnd = 33 + (proofLength << 5);\n\n        // Minimum remaining data after proof: keyId (2)\n        if (data.length < proofEnd + 2) return false;\n\n        bytes32 merkleRoot = bytes32(data[1:33]);\n\n        {\n            // Assembly constructs a calldata slice for the bytes32[] proof array without copying\n            // to memory. This sets the ABI calldata pointer and length for MerkleProofLib to\n            // read directly from calldata, saving gas on memory allocation and copying.\n            bytes32[] calldata proof;\n            /// @solidity memory-safe-assembly\n            assembly {\n                proof.offset := add(data.offset, 33)\n                proof.length := proofLength\n            }\n            // Verify that `digest` (the operation hash) is a leaf in the merkle tree\n            if (!MerkleProofLib.verifyCalldata(proof, merkleRoot, digest)) return false;\n        }\n\n        // Extract keyId from after the proof\n        uint16 keyId = uint16(bytes2(data[proofEnd:proofEnd + 2]));\n\n        // Look up the credential by keyId — loaded into memory for cheaper repeated access\n        uint256 ck = uint256(keyId);\n        WebAuthnCredential memory cred = _passkeyCredentials[account].credentials[ck];\n        if (cred.pubKeyX == bytes32(0)) return false;\n\n        // Parse WebAuthnAuth from remaining calldata after the 2-byte keyId\n        (WebAuthn.WebAuthnAuth memory auth, bool ok) = P256Lib.parseWebAuthnAuth(data[proofEnd + 2:]);\n        if (!ok) return false;\n\n        // Challenge is chain-agnostic: _passkeyMultichain wraps merkleRoot in EIP-712 without chainId\n        return WebAuthn.verify(\n            abi.encode(_passkeyMultichain(merkleRoot)), true, auth, cred.pubKeyX, cred.pubKeyY\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                METADATA\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice ERC-7579 module type check -- reports this module as both a standard validator\n     *         (TYPE_VALIDATOR) and a stateless validator (TYPE_STATELESS_VALIDATOR)\n     * @param typeID The ERC-7579 module type identifier to check\n     * @return True if this module supports the given type\n     */\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\n        return typeID == TYPE_VALIDATOR || typeID == TYPE_STATELESS_VALIDATOR;\n    }\n\n    /**\n     * @notice ERC-7579 module name\n     */\n    function name() external pure virtual returns (string memory) {\n        return \"OneAuthValidator\";\n    }\n\n    /**\n     * @notice ERC-7579 module version\n     */\n    function version() external pure virtual returns (string memory) {\n        return \"1.0.0\";\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/Modules.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n/*//////////////////////////////////////////////////////////////\n                          INTERFACES\n//////////////////////////////////////////////////////////////*/\n\nimport {\n    IValidator as IERC7579Validator,\n    IExecutor as IERC7579Executor,\n    IFallback as IERC7579Fallback,\n    IHook as IERC7579Hook,\n    IModule as IERC7579Module\n} from \"./accounts/common/interfaces/IERC7579Module.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            BASES\n//////////////////////////////////////////////////////////////*/\n\n// Core\nimport { ERC7579ModuleBase } from \"./module-bases/ERC7579ModuleBase.sol\";\n\n// Validators\nimport { ERC7579ValidatorBase } from \"./module-bases/ERC7579ValidatorBase.sol\";\nimport { ERC7579StatelessValidatorBase } from \"./module-bases/ERC7579StatelessValidatorBase.sol\";\nimport { ERC7579HybridValidatorBase } from \"./module-bases/ERC7579HybridValidatorBase.sol\";\n\n// Executors\nimport { ERC7579ExecutorBase } from \"./module-bases/ERC7579ExecutorBase.sol\";\n\n// Hooks\nimport { ERC7579HookBase } from \"./module-bases/ERC7579HookBase.sol\";\nimport { ERC7579HookDestruct } from \"./module-bases/ERC7579HookDestruct.sol\";\n\n// Fallbacks\nimport { ERC7579FallbackBase } from \"./module-bases/ERC7579FallbackBase.sol\";\n\n// Misc\nimport { SchedulingBase } from \"./module-bases/SchedulingBase.sol\";\nimport { ERC7484RegistryAdapter } from \"./module-bases/ERC7484RegistryAdapter.sol\";\n\n// Policies\nimport { ERC7579PolicyBase } from \"./module-bases/ERC7579PolicyBase.sol\";\nimport { ERC1271Policy } from \"./module-bases/ERC1271Policy.sol\";\nimport { ERC7579ActionPolicy } from \"./module-bases/ERC7579ActionPolicy.sol\";\nimport { ERC7579UserOpPolicy } from \"./module-bases/ERC7579UserOpPolicy.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            UTIL\n//////////////////////////////////////////////////////////////*/\n\nimport { TrustedForwarder } from \"./module-bases/utils/TrustedForwarder.sol\";\n"},"node_modules/@rhinestone/modulekit/src/external/ERC4337.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n/*//////////////////////////////////////////////////////////////\n                            USEROP\n//////////////////////////////////////////////////////////////*/\n\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport { UserOperationLib } from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            ENTRYPOINT\n//////////////////////////////////////////////////////////////*/\n\nimport { EntryPointSimulations } from\n    \"@ERC4337/account-abstraction/contracts/core/EntryPointSimulations.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            VALIDATION\n//////////////////////////////////////////////////////////////*/\n\nimport {\n    ValidationData,\n    _packValidationData\n} from \"@ERC4337/account-abstraction/contracts/core/Helpers.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            INTERFACES\n//////////////////////////////////////////////////////////////*/\n\nimport { IStakeManager } from \"@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol\";\nimport { IAccount as IERC4337 } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol\";\nimport { IAccountExecute } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IAccountExecute.sol\";\nimport { IEntryPoint } from \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport { IEntryPointSimulations } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPointSimulations.sol\";\n"},"node_modules/solady/src/utils/MerkleProofLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\nlibrary MerkleProofLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(proof) {\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let offset := add(proof, 0x20)\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(offset, shl(5, mload(proof)))\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, mload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), mload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    ///\n    /// Note:\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\n    ///   will always return false.\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\n    /// - Any non-zero word in the `flags` array is treated as true.\n    /// - The memory offset of `proof` must be non-zero\n    ///   (i.e. `proof` is not pointing to the scratch space).\n    function verifyMultiProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32[] memory leaves,\n        bool[] memory flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the lengths of the arrays.\n            let leavesLength := mload(leaves)\n            let proofLength := mload(proof)\n            let flagsLength := mload(flags)\n\n            // Advance the pointers of the arrays to point to the data.\n            leaves := add(0x20, leaves)\n            proof := add(0x20, proof)\n            flags := add(0x20, flags)\n\n            // If the number of flags is correct.\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flagsLength) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof, shl(5, proofLength))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                leavesLength := shl(5, leavesLength)\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\n                }\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, leavesLength)\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flagsLength := add(hashesBack, shl(5, flagsLength))\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(mload(flags)) {\n                        // Loads the next proof.\n                        b := mload(proof)\n                        proof := add(proof, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag.\n                    flags := add(flags, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flagsLength)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof)\n                    )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    ///\n    /// Note:\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\n    ///   will always return false.\n    /// - Any non-zero word in the `flags` array is treated as true.\n    /// - The calldata offset of `proof` must be non-zero\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\n    function verifyMultiProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the number of flags is correct.\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flags.length) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    // forgefmt: disable-next-item\n                    isValid := eq(\n                        calldataload(\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof.offset, shl(5, proof.length))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flags.length := add(hashesBack, shl(5, flags.length))\n\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\n                // as they are pass-by-value (this trick may not always save gas).\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flags.offset)) {\n                        // Loads the next proof.\n                        b := calldataload(proof.offset)\n                        proof.offset := add(proof.offset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag offset.\n                    flags.offset := add(flags.offset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flags.length)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof.offset)\n                    )\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            proof.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leaves.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bool array.\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            flags.length := 0\n        }\n    }\n}\n"},"node_modules/solady/src/utils/EnumerableSetLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for managing enumerable sets in storage.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EnumerableSetLib.sol)\n///\n/// @dev Note:\n/// In many applications, the number of elements in an enumerable set is small.\n/// This enumerable set implementation avoids storing the length and indices\n/// for up to 3 elements. Once the length exceeds 3 for the first time, the length\n/// and indices will be initialized. The amortized cost of adding elements is O(1).\n///\n/// The AddressSet implementation packs the length with the 0th entry.\n///\n/// All enumerable sets except Uint8Set use a pop and swap mechanism to remove elements.\n/// This means that the iteration order of elements can change between element removals.\nlibrary EnumerableSetLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The index must be less than the length.\n    error IndexOutOfBounds();\n\n    /// @dev The value cannot be the zero sentinel.\n    error ValueIsZeroSentinel();\n\n    /// @dev Cannot accommodate a new unique value with the capacity.\n    error ExceedsCapacity();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The index to represent a value that does not exist.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev A sentinel value to denote the zero value in storage.\n    /// No elements can be equal to this value.\n    /// `uint72(bytes9(keccak256(bytes(\"_ZERO_SENTINEL\"))))`.\n    uint256 private constant _ZERO_SENTINEL = 0xfbb67fda52d4bfb8bf;\n\n    /// @dev The storage layout is given by:\n    /// ```\n    ///     mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n    ///     mstore(0x00, set.slot)\n    ///     let rootSlot := keccak256(0x00, 0x24)\n    ///     mstore(0x20, rootSlot)\n    ///     mstore(0x00, shr(96, shl(96, value)))\n    ///     let positionSlot := keccak256(0x00, 0x40)\n    ///     let valueSlot := add(rootSlot, sload(positionSlot))\n    ///     let valueInStorage := shr(96, sload(valueSlot))\n    ///     let lazyLength := shr(160, shl(160, sload(rootSlot)))\n    /// ```\n    uint256 private constant _ENUMERABLE_ADDRESS_SET_SLOT_SEED = 0x978aab92;\n\n    /// @dev The storage layout is given by:\n    /// ```\n    ///     mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n    ///     mstore(0x00, set.slot)\n    ///     let rootSlot := keccak256(0x00, 0x24)\n    ///     mstore(0x20, rootSlot)\n    ///     mstore(0x00, value)\n    ///     let positionSlot := keccak256(0x00, 0x40)\n    ///     let valueSlot := add(rootSlot, sload(positionSlot))\n    ///     let valueInStorage := sload(valueSlot)\n    ///     let lazyLength := sload(not(rootSlot))\n    /// ```\n    uint256 private constant _ENUMERABLE_WORD_SET_SLOT_SEED = 0x18fb5864;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev An enumerable address set in storage.\n    struct AddressSet {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable bytes32 set in storage.\n    struct Bytes32Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable uint256 set in storage.\n    struct Uint256Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable int256 set in storage.\n    struct Int256Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable uint8 set in storage. Useful for enums.\n    struct Uint8Set {\n        uint256 data;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     GETTERS / SETTERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of elements in the set.\n    function length(AddressSet storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := shr(1, n)\n            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Bytes32Set storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(not(rootSlot))\n            result := shr(1, n)\n            for {} iszero(n) {} {\n                result := 0\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Uint256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Int256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Uint8Set storage set) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload(set.slot) } packed { result := add(1, result) } {\n                packed := xor(packed, and(packed, add(1, not(packed))))\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(AddressSet storage set, address value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    result := 1\n                    if eq(sload(rootSlot), value) { break }\n                    if eq(sload(add(rootSlot, 1)), value) { break }\n                    if eq(sload(add(rootSlot, 2)), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Uint256Set storage set, uint256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Int256Set storage set, int256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Uint8Set storage set, uint8 value) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, shr(and(0xff, value), sload(set.slot)))\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := shr(96, rootPacked)\n                    if iszero(v0) {\n                        sstore(rootSlot, shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := shr(96, sload(add(rootSlot, 1)))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := shr(96, sload(add(rootSlot, 2)))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    rootPacked := or(rootPacked, 7)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    result := 1\n                    sstore(p, add(1, n))\n                    if iszero(n) {\n                        sstore(rootSlot, or(3, shl(96, value)))\n                        break\n                    }\n                    sstore(add(rootSlot, n), shl(96, value))\n                    sstore(rootSlot, add(2, rootPacked))\n                    break\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := sload(rootSlot)\n                    if iszero(v0) {\n                        sstore(rootSlot, value)\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := sload(add(rootSlot, 1))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := sload(add(rootSlot, 2))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), value)\n                    sstore(p, add(1, n))\n                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, or(result, mask))\n            result := iszero(and(result, mask))\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(AddressSet storage set, address value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Bytes32Set storage set, bytes32 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Uint256Set storage set, uint256 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Int256Set storage set, int256 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Uint8Set storage set, uint8 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := shr(96, sload(add(rootSlot, n)))\n                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(sload(rootSlot), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := sload(add(rootSlot, n))\n                    sstore(add(rootSlot, sub(position, 1)), lastValue)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(not(rootSlot), or(shl(1, n), 1))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, and(result, not(mask)))\n            result := iszero(iszero(and(result, mask)))\n        }\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(AddressSet storage set, address value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Bytes32Set storage set, bytes32 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Uint256Set storage set, uint256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Int256Set storage set, int256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Uint8Set storage set, uint8 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(AddressSet storage set) internal view returns (address[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            let v := shr(96, rootPacked)\n            mstore(o, mul(v, iszero(eq(v, zs))))\n            for {} 1 {} {\n                if iszero(n) {\n                    if v {\n                        n := 1\n                        v := shr(96, sload(add(rootSlot, n)))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := shr(96, sload(add(rootSlot, n)))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                    v := shr(96, sload(add(rootSlot, i)))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let n := sload(not(rootSlot))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            for {} 1 {} {\n                if iszero(n) {\n                    let v := sload(rootSlot)\n                    if v {\n                        n := 1\n                        mstore(o, mul(v, iszero(eq(v, zs))))\n                        v := sload(add(rootSlot, n))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := sload(add(rootSlot, n))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                    let v := sload(add(rootSlot, i))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Uint256Set storage set) internal view returns (uint256[] memory result) {\n        result = _toUints(values(_toBytes32Set(set)));\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Int256Set storage set) internal view returns (int256[] memory result) {\n        result = _toInts(values(_toBytes32Set(set)));\n    }\n\n    /// @dev Returns all of the values in the set.\n    function values(Uint8Set storage set) internal view returns (uint8[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let ptr := add(result, 0x20)\n            let o := 0\n            for { let packed := sload(set.slot) } packed {} {\n                if iszero(and(packed, 0xffff)) {\n                    o := add(o, 16)\n                    packed := shr(16, packed)\n                    continue\n                }\n                mstore(ptr, o)\n                ptr := add(ptr, shl(5, and(packed, 1)))\n                o := add(o, 1)\n                packed := shr(1, packed)\n            }\n            mstore(result, shr(5, sub(ptr, add(result, 0x20))))\n            mstore(0x40, ptr)\n        }\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(AddressSet storage set, uint256 i) internal view returns (address result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(96, sload(add(rootSlot, i)))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {\n        result = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(add(result, i))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = uint256(at(_toBytes32Set(set), i));\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Int256Set storage set, uint256 i) internal view returns (int256 result) {\n        result = int256(uint256(at(_toBytes32Set(set), i)));\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Uint8Set storage set, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(set.slot)\n            for {} 1 {\n                mstore(0x00, 0x4e23d035) // `IndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            } {\n                if iszero(lt(i, 256)) { continue }\n                for { let j := 0 } iszero(eq(i, j)) {} {\n                    packed := xor(packed, and(packed, add(1, not(packed))))\n                    j := add(j, 1)\n                }\n                if iszero(packed) { continue }\n                break\n            }\n            // Find first set subroutine, optimized for smaller bytecode size.\n            let x := and(packed, add(1, not(packed)))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            result := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(AddressSet storage set, address value)\n        internal\n        view\n        returns (uint256 result)\n    {\n        result = NOT_FOUND;\n        if (uint160(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            result := not(0)\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    if eq(shr(96, rootPacked), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (uint256 result)\n    {\n        result = NOT_FOUND;\n        if (uint256(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    if eq(sload(rootSlot), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(i));\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Int256Set storage set, int256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(uint256(i)));\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Uint8Set storage set, uint8 value) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let packed := sload(set.slot)\n            let m := shl(and(0xff, value), 1)\n            if and(packed, m) {\n                result := 0\n                for { let p := and(packed, sub(m, 1)) } p {} {\n                    p := xor(p, and(p, add(1, not(p))))\n                    result := add(result, 1)\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the root slot.\n    function _rootSlot(AddressSet storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }\n\n    /// @dev Returns the root slot.\n    function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }\n\n    /// @dev Casts to a Bytes32Set.\n    function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }\n\n    /// @dev Casts to a Bytes32Set.\n    function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }\n\n    /// @dev Casts to a uint256 array.\n    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }\n\n    /// @dev Casts to a int256 array.\n    function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }\n}\n"},"node_modules/solady/src/utils/EfficientHashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      EQUALITY CHECKS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }\n\n    /// @dev Returns `abi.decode(a, (bytes32)) == a`.\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      SHA2-256 HELPERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n}\n"},"node_modules/solady/src/utils/WebAuthn.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Base64} from \"./Base64.sol\";\nimport {P256} from \"./P256.sol\";\n\n/// @notice WebAuthn helper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/WebAuthn.sol)\n/// @author Modified from Daimo WebAuthn (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)\n/// @author Modified from Coinbase WebAuthn (https://github.com/base-org/webauthn-sol/blob/main/src/WebAuthn.sol)\nlibrary WebAuthn {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Helps make encoding and decoding easier, alleviates stack-too-deep.\n    struct WebAuthnAuth {\n        // The WebAuthn authenticator data.\n        // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata.\n        bytes authenticatorData;\n        // The WebAuthn client data JSON.\n        // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson.\n        string clientDataJSON;\n        // Start index of \"challenge\":\"...\" in `clientDataJSON`.\n        uint256 challengeIndex;\n        // Start index of \"type\":\"...\" in `clientDataJSON`.\n        uint256 typeIndex;\n        // The r value of secp256r1 signature.\n        bytes32 r;\n        // The s value of secp256r1 signature.\n        bytes32 s;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              WEBAUTHN VERIFICATION OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Verifies a Webauthn Authentication Assertion.\n    /// See: https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion.\n    ///\n    /// We do not verify all the steps as described in the specification, only ones\n    /// relevant to our context. Please carefully read through this list before usage.\n    ///\n    /// Specifically, we do verify the following:\n    /// - Verify that `authenticatorData` (which comes from the authenticator,\n    ///   such as iCloud Keychain) indicates a well-formed assertion with the\n    ///   \"User Present\" bit set. If `requireUserVerification` is set, checks that the\n    ///   authenticator enforced user verification. User verification should be required\n    ///   if, and only if, `options.userVerification` is set to required in the request.\n    /// - Verifies that the client JSON is of type \"webauthn.get\",\n    ///   i.e. the client was responding to a request to assert authentication.\n    /// - Verifies that the client JSON contains the requested challenge.\n    /// - Verifies that (r, s) constitute a valid signature over both the\n    ///   `authData` and client JSON, for public key (x, y).\n    ///\n    /// We make some assumptions about the particular use case of this verifier,\n    /// so we do NOT verify the following:\n    /// - Does NOT verify that the origin in the `clientDataJSON` matches the\n    ///   Relying Party's origin: it is considered the authenticator's responsibility to\n    ///   ensure that the user is interacting with the correct RP. This is enforced by\n    ///   most high quality authenticators properly, particularly the iCloud Keychain\n    ///   and Google Password Manager were tested.\n    /// - Does NOT verify That `topOrigin` in `clientDataJSON` is well-formed:\n    ///   We assume it would never be present, i.e. the credentials are never used in a\n    ///   cross-origin/iframe context. The website/app set up should disallow cross-origin\n    ///   usage of the credentials. This is the default behavior for created credentials\n    ///   in common settings.\n    /// - Does NOT verify that the `rpIdHash` in `authenticatorData` is the SHA-256 hash\n    ///   of the RP ID expected by the Relying Party:\n    ///   this means that we rely on the authenticator to properly enforce\n    ///   credentials to be used only by the correct RP.\n    ///   This is generally enforced with features like Apple App Site Association\n    ///   and Google Asset Links. To protect from edge cases in which a previously-linked\n    ///   RP ID is removed from the authorized RP IDs, we recommend that messages\n    ///   signed by the authenticator include some expiry mechanism.\n    /// - Does NOT verify the credential backup state: this assumes the credential backup\n    ///   state is NOT used as part of Relying Party business logic or policy.\n    /// - Does NOT verify the values of the client extension outputs:\n    ///   this assumes that the Relying Party does not use client extension outputs.\n    /// - Does NOT verify the signature counter: signature counters are intended to enable\n    ///   risk scoring for the Relying Party. This assumes risk scoring is not used as part\n    ///   of Relying Party business logic or policy.\n    /// - Does NOT verify the attestation object: this assumes that\n    ///   response.attestationObject is NOT present in the response,\n    ///   i.e. the RP does not intend to verify an attestation.\n    function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        WebAuthnAuth memory auth,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool result) {\n        bytes32 messageHash;\n        string memory encoded = Base64.encode(challenge, true, true);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let clientDataJSON := mload(add(auth, 0x20))\n            let n := mload(clientDataJSON) // `clientDataJSON`'s length.\n            let o := add(clientDataJSON, 0x20) // Start of `clientData`'s bytes.\n            {\n                let c := mload(add(auth, 0x40)) // Challenge index in `clientDataJSON`.\n                let t := mload(add(auth, 0x60)) // Type index in `clientDataJSON`.\n                let l := mload(encoded) // Cache `encoded`'s length.\n                let q := add(l, 0x0d) // Length of `encoded` prefixed with '\"challenge\":\"'.\n                mstore(encoded, shr(152, '\"challenge\":\"')) // Temp prefix with '\"challenge\":\"'.\n                result :=\n                    and(\n                        // 11. Verify JSON's type. Also checks for possible addition overflows.\n                        and(\n                            eq(shr(88, mload(add(o, t))), shr(88, '\"type\":\"webauthn.get\"')),\n                            lt(shr(128, or(t, c)), lt(add(0x14, t), n))\n                        ),\n                        // 12. Verify JSON's challenge. Includes a check for the closing '\"'.\n                        and(\n                            eq(keccak256(add(o, c), q), keccak256(add(encoded, 0x13), q)),\n                            and(eq(byte(0, mload(add(add(o, c), q))), 34), lt(add(q, c), n))\n                        )\n                    )\n                mstore(encoded, l) // Restore `encoded`'s length, in case of string interning.\n            }\n            // Skip 13., 14., 15.\n            let l := mload(mload(auth)) // Length of `authenticatorData`.\n            // 16. Verify that the \"User Present\" flag is set (bit 0).\n            // 17. Verify that the \"User Verified\" flag is set (bit 2), if required.\n            // See: https://www.w3.org/TR/webauthn-2/#flags.\n            let u := or(1, shl(2, iszero(iszero(requireUserVerification))))\n            result := and(and(result, gt(l, 0x20)), eq(and(mload(add(mload(auth), 0x21)), u), u))\n            if result {\n                let p := add(mload(auth), 0x20) // Start of `authenticatorData`'s bytes.\n                let e := add(p, l) // Location of the word after `authenticatorData`.\n                let w := mload(e) // Cache the word after `authenticatorData`.\n                // 19. Compute `sha256(clientDataJSON)`.\n                // 20. Compute `sha256(authenticatorData ‖ sha256(clientDataJSON))`.\n                // forgefmt: disable-next-item\n                messageHash := mload(staticcall(gas(),\n                    shl(1, staticcall(gas(), 2, o, n, e, 0x20)), p, add(l, 0x20), 0x01, 0x20))\n                mstore(e, w) // Restore the word after `authenticatorData`, in case of reuse.\n                // `returndatasize()` is `0x20` on `sha256` success, and `0x00` otherwise.\n                if iszero(returndatasize()) { invalid() }\n            }\n        }\n        // `P256.verifySignature` returns false if `s > N/2` due to the malleability check.\n        if (result) result = P256.verifySignature(messageHash, auth.r, auth.s, x, y);\n    }\n\n    /// @dev Plain variant of verify.\n    function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        bytes memory authenticatorData,\n        string memory clientDataJSON,\n        uint256 challengeIndex,\n        uint256 typeIndex,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool) {\n        return verify(\n            challenge,\n            requireUserVerification,\n            WebAuthnAuth(authenticatorData, clientDataJSON, challengeIndex, typeIndex, r, s),\n            x,\n            y\n        );\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                ENCODING / DECODING HELPERS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `abi.encode(auth)`.\n    function encodeAuth(WebAuthnAuth memory auth) internal pure returns (bytes memory) {\n        return abi.encode(auth);\n    }\n\n    /// @dev Performs a best-effort attempt to `abi.decode(auth)`. Won't revert.\n    /// If any fields cannot be successfully extracted, `decoded` will not be populated,\n    /// which will cause `verify` to return false (as `clientDataJSON` is empty).\n    function tryDecodeAuth(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let n := mload(encodedAuth) } iszero(lt(n, 0xc0)) {} {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                let p := add(mload(o), o) // Start of `encodedAuth`.\n                if or(gt(add(p, 0xc0), e), lt(p, o)) { break }\n                let authenticatorData := add(mload(p), p)\n                let clientDataJSON := add(mload(add(p, 0x20)), p)\n                if or(\n                    or(gt(authenticatorData, e), lt(authenticatorData, p)),\n                    or(gt(clientDataJSON, e), lt(clientDataJSON, p))\n                ) { break }\n                if or(\n                    gt(add(add(authenticatorData, 0x20), mload(authenticatorData)), e),\n                    gt(add(add(clientDataJSON, 0x20), mload(clientDataJSON)), e)\n                ) { break }\n                mstore(decoded, authenticatorData) // `authenticatorData`.\n                mstore(add(decoded, 0x20), clientDataJSON) // `clientDataJSON`.\n                mstore(add(decoded, 0x40), mload(add(p, 0x40))) // `challengeIndex`.\n                mstore(add(decoded, 0x60), mload(add(p, 0x60))) // `typeIndex`.\n                mstore(add(decoded, 0x80), mload(add(p, 0x80))) // `r`.\n                mstore(add(decoded, 0xa0), mload(add(p, 0xa0))) // `s`.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the compact encoding of `auth`:\n    /// ```\n    ///     abi.encodePacked(\n    ///         uint16(auth.authenticatorData.length),\n    ///         bytes(auth.authenticatorData),\n    ///         bytes(auth.clientDataJSON),\n    ///         uint16(auth.challengeIndex),\n    ///         uint16(auth.typeIndex),\n    ///         bytes32(auth.r),\n    ///         bytes32(auth.s)\n    ///     )\n    /// ```\n    /// Returns the empty string if any length or index exceeds 16 bits.\n    function tryEncodeAuthCompact(WebAuthnAuth memory auth)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copyBytes(o_, s_, c_) -> _e {\n                mstore(o_, shl(240, mload(s_)))\n                o_ := add(o_, c_)\n                _e := add(o_, mload(s_)) // The end of the bytes.\n                for { let d_ := sub(add(0x20, s_), o_) } 1 {} {\n                    mstore(o_, mload(add(d_, o_)))\n                    o_ := add(o_, 0x20)\n                    if iszero(lt(o_, _e)) { break }\n                }\n            }\n            let clientDataJSON := mload(add(0x20, auth))\n            let c := mload(add(0x40, auth)) // `challengeIndex`.\n            let t := mload(add(0x60, auth)) // `typeIndex`.\n            // If none of the lengths are more than `0xffff`.\n            if iszero(shr(16, or(or(t, c), or(mload(mload(auth)), mload(clientDataJSON))))) {\n                result := mload(0x40)\n                // `authenticatorData`, `clientDataJSON`.\n                let o := copyBytes(copyBytes(add(result, 0x20), mload(auth), 2), clientDataJSON, 0)\n                mstore(o, or(shl(240, c), shl(224, t))) // `challengeIndex`, `typeIndex`.\n                mstore(add(o, 0x04), mload(add(0x80, auth))) // `r`.\n                mstore(add(o, 0x24), mload(add(0xa0, auth))) // `s`.\n                mstore(result, sub(add(o, 0x24), result)) // Store the length.\n                mstore(add(o, 0x44), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x64)) // Allocate memory .\n            }\n        }\n    }\n\n    /// @dev Approximately the same gas as `tryDecodeAuth`, but helps save on calldata.\n    /// If any fields cannot be successfully extracted, `decoded` will not be populated,\n    /// which will cause `verify` to return false (as `clientDataJSON` is empty).\n    function tryDecodeAuthCompact(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                for { let i_ := 0 } 1 {} {\n                    mstore(add(s_, i_), mload(add(o_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, l_)) { break }\n                }\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            let n := mload(encodedAuth)\n            if iszero(lt(n, 0x46)) {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                n := shr(240, mload(o)) // Length of `authenticatorData`.\n                let a := add(o, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, mload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, mload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), mload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), mload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }\n\n    /// @dev Calldata variant of `tryDecodeAuthCompact`.\n    function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                calldatacopy(s_, o_, l_)\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            if iszero(lt(encodedAuth.length, 0x46)) {\n                let e := add(encodedAuth.offset, encodedAuth.length) // End of `encodedAuth`.\n                let n := shr(240, calldataload(encodedAuth.offset)) // Length of `authenticatorData`.\n                let a := add(encodedAuth.offset, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, calldataload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, calldataload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), calldataload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), calldataload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/utils/ERC7579Constants.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_POLICY = 5;\nuint256 constant MODULE_TYPE_SIGNER = 6;\nuint256 constant MODULE_TYPE_STATELESS_VALIDATOR = 7;\n"},"src/OneAuth/OneAuthRecoveryBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\nimport { EIP712Lib } from \"./lib/EIP712Lib.sol\";\n\n/// @title OneAuthRecoveryBase\n/// @notice Abstract recovery mixin for OneAuth validators with EIP-712 typed data\n/// @dev Provides two recovery paths:\n///      1. Existing passkey signs an EIP-712 RecoverPasskey message (`recoverWithPasskey`)\n///      2. Guardian signs the same EIP-712 message (`recoverWithGuardian`)\n///\n///      Supports two guardian types per account with a configurable threshold:\n///      - **User guardian**: a simple address (typically EOA) stored in GuardianConfig.\n///        No contract deployment needed — ideal for a single trusted contact.\n///      - **External guardian**: a Guardian.sol contract (EIP-1271). For M-of-N multisig cases\n///        that need the full Guardian contract.\n///      Both are optional. The **threshold** controls how many guardians must sign:\n///      - threshold=1: recovery can be authorized by either guardian, selected via a type byte\n///        prefix in `guardianSig`: `0x00` for user guardian, `0x01` for external guardian.\n///      - threshold=2: both guardians must sign. The `guardianSig` format is\n///        `[user_sig_len: uint16][user_sig][external_sig]`.\n///\n///      Guardian configuration (addresses + threshold) is set via `setGuardianConfig()`.\n///      All changes take effect immediately.\n///\n///      Uses chain-agnostic domain separator with chainId in the struct for cross-chain recovery.\n///      chainId = 0 means valid on any chain; a non-zero chainId restricts recovery to that chain.\n///      Inheriting contract must implement the abstract hooks `_validateSignatureWithConfig`\n///      and `_addCredentialRecovery`.\n///\n///      SECURITY CONSIDERATIONS:\n///\n///      - Recovery supports in-place rotation: When `replace` is true in the `NewCredential`\n///        struct, the credential at `keyId` has its public key overwritten in-place,\n///        preventing the compromised key from being used. When `replace` is false,\n///        recovery is additive only (new credential added, existing keys remain active).\n///\n///      - Recovery nonces survive uninstallation: `onUninstall` (in the inheriting contract)\n///        does NOT clear the `nonceUsed` mapping. This is intentional -- it prevents replay\n///        of old recovery signatures if the module is reinstalled.\n///\n///      - Chain-agnostic domain with chainId in struct: Recovery uses\n///        `_hashTypedDataSansChainId` for the domain separator (no chainId in domain) but\n///        embeds `chainId` in the struct hash. This allows cross-chain recovery with\n///        chainId=0 while still supporting chain-specific recovery with a non-zero chainId.\nabstract contract OneAuthRecoveryBase is EIP712 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when guardian configuration is applied for an account\n    event GuardianConfigSet(\n        address indexed account, address userGuardian, address externalGuardian, uint8 threshold\n    );\n\n    /// @notice Emitted when a recovery is executed via an existing passkey signature\n    event PasskeyRecoveryExecuted(address indexed account, uint16 indexed newKeyId, uint256 nonce);\n\n    /// @notice Emitted when a recovery is executed via a guardian signature\n    event GuardianRecoveryExecuted(\n        address indexed account, address indexed guardian, uint16 indexed newKeyId, uint256 nonce\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown when block.timestamp exceeds the recovery message's expiry timestamp\n    error RecoveryExpired();\n\n    /// @notice Thrown when the recovery nonce has already been consumed (replay protection)\n    error NonceAlreadyUsed();\n\n    /// @notice Thrown in `recoverWithGuardian` when the selected guardian type is not configured\n    error GuardianNotConfigured();\n\n    /// @notice Thrown in `recoverWithPasskey` when the passkey signature over the recovery digest is invalid\n    error InvalidRecoverySignature();\n\n    /// @notice Thrown in `recoverWithGuardian` when the guardian's signature over the recovery digest is invalid\n    error InvalidGuardianSignature();\n\n    /// @notice Thrown when chainId is non-zero and does not match the current block.chainid\n    error InvalidChainId();\n\n    /// @notice Thrown when the guardian type byte prefix is not 0x00 or 0x01\n    error InvalidGuardianType();\n\n    /// @notice Thrown when guardianSig is empty (no type byte)\n    error EmptyGuardianSignature();\n\n    /// @notice Thrown when threshold is not 1 or 2\n    error InvalidThreshold();\n\n    /// @notice Thrown when threshold=2 but both guardians are not configured\n    error ThresholdRequiresBothGuardians();\n\n    /*//////////////////////////////////////////////////////////////\n                               STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Parameters for a new WebAuthn credential to be added during recovery\n    struct NewCredential {\n        uint16 keyId;\n        bytes32 pubKeyX;\n        bytes32 pubKeyY;\n        bool replace;\n    }\n\n    /// @notice Guardian addresses and signing threshold\n    /// @dev threshold=1: either guardian can authorize recovery alone\n    ///      threshold=2: both guardians must sign\n    ///      threshold=0: treated as 1 (default for zero-initialized storage)\n    struct GuardianConfig {\n        address userGuardian;\n        address externalGuardian;\n        uint8 threshold;\n    }\n\n    /// @notice Per-account recovery configuration\n    /// @dev The nonceUsed mapping is intentionally NOT cleared on uninstall to prevent\n    ///      replay of old recovery signatures if the module is reinstalled\n    struct RecoveryConfig {\n        GuardianConfig guardian;\n        mapping(uint256 nonce => bool) nonceUsed;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Recovery configuration per smart account\n    mapping(address account => RecoveryConfig) internal _recoveryConfig;\n\n    /*//////////////////////////////////////////////////////////////\n                              EIP-712 DOMAIN\n    //////////////////////////////////////////////////////////////*/\n\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"OneAuthValidator\";\n        version = \"1.0.0\";\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ABSTRACT HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    function _validateSignatureWithConfig(\n        address account,\n        bytes32 digest,\n        bytes calldata data\n    )\n        internal\n        view\n        virtual\n        returns (bool);\n\n    function _addCredentialRecovery(address account, NewCredential calldata cred) internal virtual;\n\n    /*//////////////////////////////////////////////////////////////\n                              MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier validRecovery(address account, uint256 chainId, uint256 nonce, uint48 expiry) {\n        if (block.timestamp > expiry) revert RecoveryExpired();\n        if (_recoveryConfig[account].nonceUsed[nonce]) revert NonceAlreadyUsed();\n        if (chainId != 0 && chainId != block.chainid) revert InvalidChainId();\n        _recoveryConfig[account].nonceUsed[nonce] = true;\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONFIGURATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal immediate guardian config set — used by onInstall\n    function _setGuardianConfigImmediate(\n        address account,\n        address _userGuardian,\n        address _externalGuardian,\n        uint8 _threshold\n    )\n        internal\n    {\n        if (_threshold > 2) revert InvalidThreshold();\n        if (_threshold == 2) {\n            if (_userGuardian == address(0) || _externalGuardian == address(0)) {\n                revert ThresholdRequiresBothGuardians();\n            }\n        }\n\n        GuardianConfig storage gc = _recoveryConfig[account].guardian;\n        gc.userGuardian = _userGuardian;\n        gc.externalGuardian = _externalGuardian;\n        gc.threshold = _threshold;\n\n        emit GuardianConfigSet(account, _userGuardian, _externalGuardian, _threshold);\n    }\n\n    /// @notice Set or change the guardian configuration for the caller's account\n    /// @param _userGuardian Address of the user guardian (address(0) to clear)\n    /// @param _externalGuardian Address of the external guardian (address(0) to clear)\n    /// @param _threshold 1 = either guardian, 2 = both required\n    function setGuardianConfig(\n        address _userGuardian,\n        address _externalGuardian,\n        uint8 _threshold\n    )\n        external\n    {\n        if (_threshold == 0 || _threshold > 2) revert InvalidThreshold();\n        if (_threshold == 2) {\n            if (_userGuardian == address(0) || _externalGuardian == address(0)) {\n                revert ThresholdRequiresBothGuardians();\n            }\n        }\n\n        GuardianConfig storage gc = _recoveryConfig[msg.sender].guardian;\n        gc.userGuardian = _userGuardian;\n        gc.externalGuardian = _externalGuardian;\n        gc.threshold = _threshold;\n\n        emit GuardianConfigSet(msg.sender, _userGuardian, _externalGuardian, _threshold);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                RECOVERY\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Recovers an account by adding or replacing a credential, authorized by an existing passkey\n     * @dev Callable by anyone (permissionless) -- security relies entirely on the cryptographic\n     *      verification of the existing passkey's signature over the EIP-712 recovery digest.\n     */\n    function recoverWithPasskey(\n        address account,\n        uint256 chainId,\n        NewCredential calldata cred,\n        uint256 nonce,\n        uint48 expiry,\n        bytes calldata signature\n    )\n        external\n        validRecovery(account, chainId, nonce, expiry)\n    {\n        bytes32 digest = getRecoverDigest(account, chainId, cred, nonce, expiry);\n\n        if (!_validateSignatureWithConfig(account, digest, signature)) {\n            revert InvalidRecoverySignature();\n        }\n\n        _addCredentialRecovery(account, cred);\n\n        emit PasskeyRecoveryExecuted(account, cred.keyId, nonce);\n    }\n\n    /**\n     * @notice Recovers an account by adding or replacing a credential, authorized by guardian(s)\n     * @dev Callable by anyone (permissionless). Signature format depends on the account's threshold:\n     *      - threshold=1: `[type_byte][sig]` where type_byte is `0x00` (user) or `0x01` (external)\n     *      - threshold=2: `[user_sig_len: uint16][user_sig][external_sig]` (both must sign)\n     */\n    function recoverWithGuardian(\n        address account,\n        uint256 chainId,\n        NewCredential calldata cred,\n        uint256 nonce,\n        uint48 expiry,\n        bytes calldata guardianSig\n    )\n        external\n        validRecovery(account, chainId, nonce, expiry)\n    {\n        _executeGuardianRecovery(account, chainId, cred, nonce, expiry, guardianSig);\n    }\n\n    function _executeGuardianRecovery(\n        address account,\n        uint256 chainId,\n        NewCredential calldata cred,\n        uint256 nonce,\n        uint48 expiry,\n        bytes calldata guardianSig\n    )\n        internal\n    {\n        bytes32 digest = getRecoverDigest(account, chainId, cred, nonce, expiry);\n        GuardianConfig storage gc = _recoveryConfig[account].guardian;\n        uint8 t = gc.threshold;\n\n        // threshold == 0 means default (1) for backward compatibility\n        if (t <= 1) {\n            _executeSingleGuardianRecovery(account, gc, digest, cred, nonce, guardianSig);\n        } else {\n            _executeDualGuardianRecovery(account, gc, digest, cred, nonce, guardianSig);\n        }\n    }\n\n    /// @dev Single-guardian recovery path (threshold=1). Format: [type_byte][sig]\n    function _executeSingleGuardianRecovery(\n        address account,\n        GuardianConfig storage gc,\n        bytes32 digest,\n        NewCredential calldata cred,\n        uint256 nonce,\n        bytes calldata guardianSig\n    )\n        internal\n    {\n        (address _guardian, bytes calldata sig) = _resolveGuardian(gc, guardianSig);\n\n        if (!SignatureCheckerLib.isValidSignatureNowCalldata(_guardian, digest, sig)) {\n            revert InvalidGuardianSignature();\n        }\n\n        _addCredentialRecovery(account, cred);\n\n        emit GuardianRecoveryExecuted(account, _guardian, cred.keyId, nonce);\n    }\n\n    /// @dev Dual-guardian recovery path (threshold=2). Format: [user_sig_len: uint16][user_sig][external_sig]\n    function _executeDualGuardianRecovery(\n        address account,\n        GuardianConfig storage gc,\n        bytes32 digest,\n        NewCredential calldata cred,\n        uint256 nonce,\n        bytes calldata guardianSig\n    )\n        internal\n    {\n        if (guardianSig.length < 2) revert EmptyGuardianSignature();\n\n        uint256 userSigEnd = 2 + uint256(uint16(bytes2(guardianSig[0:2])));\n        if (guardianSig.length < userSigEnd) revert InvalidGuardianSignature();\n\n        if (gc.userGuardian == address(0) || gc.externalGuardian == address(0)) {\n            revert GuardianNotConfigured();\n        }\n\n        if (!SignatureCheckerLib.isValidSignatureNowCalldata(gc.userGuardian, digest, guardianSig[2:userSigEnd]))\n        {\n            revert InvalidGuardianSignature();\n        }\n        if (!SignatureCheckerLib.isValidSignatureNowCalldata(gc.externalGuardian, digest, guardianSig[userSigEnd:]))\n        {\n            revert InvalidGuardianSignature();\n        }\n\n        address emitGuardian = gc.userGuardian;\n        _addCredentialRecovery(account, cred);\n\n        emit GuardianRecoveryExecuted(account, emitGuardian, cred.keyId, nonce);\n    }\n\n    /// @dev Parses the type byte prefix from guardianSig and resolves the guardian address\n    function _resolveGuardian(\n        GuardianConfig storage gc,\n        bytes calldata guardianSig\n    )\n        internal\n        view\n        returns (address guardian_, bytes calldata sig)\n    {\n        if (guardianSig.length == 0) revert EmptyGuardianSignature();\n\n        uint8 guardianType = uint8(guardianSig[0]);\n        sig = guardianSig[1:];\n\n        if (guardianType == 0x00) {\n            guardian_ = gc.userGuardian;\n        } else if (guardianType == 0x01) {\n            guardian_ = gc.externalGuardian;\n        } else {\n            revert InvalidGuardianType();\n        }\n\n        if (guardian_ == address(0)) revert GuardianNotConfigured();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the full guardian configuration for an account\n    function guardianConfig(address account)\n        external\n        view\n        returns (address userGuardian, address externalGuardian, uint8 threshold)\n    {\n        GuardianConfig storage gc = _recoveryConfig[account].guardian;\n        return (gc.userGuardian, gc.externalGuardian, gc.threshold);\n    }\n\n    /// @notice Returns the effective guardian threshold for an account (defaults to 1 if unset)\n    function guardianThreshold(address account) external view returns (uint8) {\n        uint8 t = _recoveryConfig[account].guardian.threshold;\n        return t == 0 ? 1 : t;\n    }\n\n    /// @notice Checks whether a specific recovery nonce has been consumed for an account\n    function nonceUsed(address account, uint256 nonce) external view returns (bool) {\n        return _recoveryConfig[account].nonceUsed[nonce];\n    }\n\n    /**\n     * @notice Computes the EIP-712 recovery digest for off-chain or on-chain verification\n     * @dev Uses `_hashTypedDataSansChainId` (chain-agnostic domain separator) so the domain\n     *      does NOT include chainId. Instead, chainId is embedded in the struct hash.\n     */\n    function getRecoverDigest(\n        address account,\n        uint256 chainId,\n        NewCredential calldata cred,\n        uint256 nonce,\n        uint48 expiry\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return _hashTypedDataSansChainId(\n            EIP712Lib.recoverPasskeyHash(\n                account, chainId, cred.keyId, cred.pubKeyX, cred.pubKeyY, cred.replace, nonce, expiry\n            )\n        );\n    }\n}\n"},"src/OneAuth/IOneAuthValidator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\n/**\n * @title IOneAuthValidator\n * @notice Events and errors for the OneAuthValidator module\n */\ninterface IOneAuthValidator {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when the module is installed for a smart account\n    event ModuleInitialized(address indexed account);\n    /// @notice Emitted when the module is uninstalled, after all credentials and guardian are cleared\n    event ModuleUninitialized(address indexed account);\n    /// @notice Emitted when a new passkey credential is registered for an account\n    event CredentialAdded(address indexed account, uint16 indexed keyId, bytes32 pubKeyX, bytes32 pubKeyY);\n    /// @notice Emitted when a passkey credential is removed from an account\n    event CredentialRemoved(address indexed account, uint16 indexed keyId);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown when signature calldata is malformed or too short to parse\n    error InvalidSignatureData();\n    /// @notice Thrown when the provided merkle proof does not verify against the merkle root\n    error InvalidMerkleProof();\n    /// @notice Thrown when proofLength exceeds MAX_MERKLE_DEPTH (DoS prevention)\n    error ProofTooLong();\n    /// @notice Thrown when a public key is not on the P-256 curve or has zero coordinates\n    error InvalidPublicKey();\n    /// @notice Thrown when attempting to remove a credential that does not exist\n    error CredentialNotFound(uint16 keyId);\n    /// @notice Thrown when attempting to remove the last remaining credential (liveness guarantee)\n    error CannotRemoveLastCredential();\n    /// @notice Thrown when adding a credential with a keyId that already exists\n    error KeyIdAlreadyExists(uint16 keyId);\n    /// @notice Thrown when the account already has MAX_CREDENTIALS registered\n    error TooManyCredentials();\n\n    // NOTE: NotInitialized(address) is also used by this module but is inherited from IERC7579Module\n}\n"},"src/OneAuth/lib/EIP712Lib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\n\n/**\n * @title EIP712Lib\n * @notice EIP-712 typehash constants and gas-efficient struct hashing for the OneAuth validator.\n * @dev Uses Solady's EfficientHashLib instead of keccak256(abi.encode(...))\n *      for gas-efficient struct hashing via direct memory operations.\n */\nlibrary EIP712Lib {\n    /*//////////////////////////////////////////////////////////////\n                             TYPEHASHES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev EIP-712 typehash for single-operation (chain-specific) passkey signing\n    bytes32 internal constant PASSKEY_DIGEST_TYPEHASH =\n        keccak256(\"PasskeyDigest(bytes32 digest)\");\n\n    /// @dev EIP-712 typehash for merkle batch (chain-agnostic) passkey signing\n    bytes32 internal constant PASSKEY_MULTICHAIN_TYPEHASH =\n        keccak256(\"PasskeyMultichain(bytes32 root)\");\n\n    /// @dev EIP-712 typehash for recovery operations\n    /// @dev replace: false = add new credential, true = in-place rotation of existing credential\n    bytes32 internal constant RECOVER_PASSKEY_TYPEHASH = keccak256(\n        \"RecoverPasskey(address account,uint256 chainId,uint16 newKeyId,bytes32 newPubKeyX,bytes32 newPubKeyY,bool replace,uint256 nonce,uint48 expiry)\"\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                         STRUCT HASH FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Struct hash for RecoverPasskey(...)\n    function recoverPasskeyHash(\n        address account,\n        uint256 chainId,\n        uint16 keyId,\n        bytes32 pubKeyX,\n        bytes32 pubKeyY,\n        bool replace,\n        uint256 nonce,\n        uint48 expiry\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return EfficientHashLib.hash(\n            RECOVER_PASSKEY_TYPEHASH,\n            bytes32(uint256(uint160(account))),\n            bytes32(chainId),\n            bytes32(uint256(keyId)),\n            pubKeyX,\n            pubKeyY,\n            bytes32(uint256(replace ? 1 : 0)),\n            bytes32(uint256(nonce)),\n            bytes32(uint256(expiry))\n        );\n    }\n}\n"},"src/OneAuth/lib/P256Lib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nimport { WebAuthn } from \"solady/utils/WebAuthn.sol\";\n\n/**\n * @title P256Lib\n * @notice P-256 (secp256r1) curve validation and WebAuthn auth parsing utilities\n * @dev Provides on-curve validation for P-256 public keys and packed WebAuthnAuth\n *      parsing used by the OneAuth validator modules.\n */\nlibrary P256Lib {\n    /*//////////////////////////////////////////////////////////////\n                            CURVE PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev P-256 field prime (modulus)\n    uint256 internal constant P =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n\n    /// @dev P-256 curve parameter a (coefficient of x in the Weierstrass equation)\n    uint256 internal constant A =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n\n    /// @dev P-256 curve parameter b (constant term in the Weierstrass equation)\n    uint256 internal constant B =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n\n    /*//////////////////////////////////////////////////////////////\n                              VALIDATION\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Validate that (x, y) is a point on the P-256 (secp256r1) curve\n     * @dev Verifies the Weierstrass equation: y^2 = x^3 + ax + b (mod p)\n     *      where a and b are the P-256 curve parameters. Also rejects the point at infinity\n     *      (zero coordinates) and values >= the field prime p.\n     * @param x X coordinate of the candidate point\n     * @param y Y coordinate of the candidate point\n     * @return True if (x, y) lies on the P-256 curve\n     */\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\n        // Reject zero coordinates (point at infinity) and values >= field prime\n        if (x == 0 || y == 0 || x >= P || y >= P) return false;\n\n        // LHS: y^2 mod p\n        uint256 lhs = mulmod(y, y, P);\n\n        // RHS: x^3 + ax + b mod p\n        // Computed as: ((x * x mod p) * x mod p) + (x * a mod p) + b, all mod p\n        uint256 rhs = addmod(\n            addmod(mulmod(mulmod(x, x, P), x, P), mulmod(x, A, P), P),\n            B,\n            P\n        );\n        return lhs == rhs;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        WEBAUTHN AUTH CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Packed WebAuthnAuth header size: r (32) + s (32) + challengeIndex (2) + typeIndex (2) + adLen (2) = 70 bytes\n    uint256 internal constant WEBAUTHN_AUTH_HEADER_SIZE = 70;\n\n    /*//////////////////////////////////////////////////////////////\n                          WEBAUTHN AUTH PARSING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Parse tightly packed WebAuthnAuth from calldata\n     * @dev Returns (auth, ok) tuple -- returns false instead of reverting when the input is\n     *      malformed. This is required because callers in the validation path must return false\n     *      (not revert) on invalid data per ERC-4337 requirements.\n     *\n     *      Packed format (avoids ABI encoding overhead for gas savings):\n     *        [0:32]              r (uint256) -- ECDSA r component\n     *        [32:64]             s (uint256) -- ECDSA s component\n     *        [64:66]             challengeIndex (uint16) -- offset of challenge in clientDataJSON\n     *        [66:68]             typeIndex (uint16) -- offset of \"type\" field in clientDataJSON\n     *        [68:70]             authenticatorDataLen (uint16) -- length of authenticatorData\n     *        [70:70+adLen]       authenticatorData (bytes) -- raw authenticator data\n     *        [70+adLen:]         clientDataJSON (bytes) -- remaining bytes are the client data\n     *\n     *      WebAuthn.WebAuthnAuth memory layout (used by the assembly blocks):\n     *        0x00: authenticatorData (bytes pointer)\n     *        0x20: clientDataJSON (bytes pointer)\n     *        0x40: challengeIndex (uint256)\n     *        0x60: typeIndex (uint256)\n     *        0x80: r (uint256)\n     *        0xa0: s (uint256)\n     * @param raw The tightly packed WebAuthnAuth calldata\n     * @return auth The parsed WebAuthnAuth struct\n     * @return ok True if parsing succeeded, false if the input was too short\n     */\n    function parseWebAuthnAuth(bytes calldata raw)\n        internal\n        pure\n        returns (WebAuthn.WebAuthnAuth memory auth, bool ok)\n    {\n        // Minimum header: r (32) + s (32) + challengeIndex (2) + typeIndex (2) + adLen (2)\n        if (raw.length < WEBAUTHN_AUTH_HEADER_SIZE) return (auth, false);\n\n        uint256 adLen;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let off := raw.offset\n\n            // First assembly block: reads scalar fields directly from calldata into the\n            // auth struct in memory. Uses calldataload for raw 32-byte reads of r and s.\n            // For the three 2-byte fields (challengeIndex, typeIndex, adLen), a single\n            // calldataload at offset 0x40 reads 32 bytes containing all three packed at the\n            // high end. Each is extracted by shifting right to position it and masking to 16 bits.\n            mstore(add(auth, 0x80), calldataload(off))           // r\n            mstore(add(auth, 0xa0), calldataload(add(off, 0x20))) // s\n\n            // Single calldataload reads 32 bytes starting at the challengeIndex position.\n            // The three uint16 fields are packed in the high bytes of this 32-byte word:\n            //   bits [240:255] = challengeIndex (shift right 240, implicit 16-bit value)\n            //   bits [224:239] = typeIndex (shift right 224, mask to 16 bits)\n            //   bits [208:223] = adLen (shift right 208, mask to 16 bits)\n            let packed := calldataload(add(off, 0x40))\n            mstore(add(auth, 0x40), shr(240, packed))                // challengeIndex\n            mstore(add(auth, 0x60), and(shr(224, packed), 0xffff))   // typeIndex\n            adLen := and(shr(208, packed), 0xffff)                   // authenticatorDataLen\n        }\n\n        // Ensure calldata is long enough to contain the authenticatorData bytes\n        if (raw.length < WEBAUTHN_AUTH_HEADER_SIZE + adLen) return (auth, false);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Second assembly block: allocates memory for the two dynamic byte arrays\n            // (authenticatorData and clientDataJSON) and sets the struct pointers.\n\n            let off := raw.offset\n            // clientDataJSON is everything after the fixed header and authenticatorData\n            let cdLen := sub(raw.length, add(WEBAUTHN_AUTH_HEADER_SIZE, adLen))\n            let fmp := mload(0x40) // current free memory pointer\n\n            // Allocate authenticatorData: write length prefix then copy bytes from calldata\n            mstore(fmp, adLen)\n            calldatacopy(add(fmp, 0x20), add(off, WEBAUTHN_AUTH_HEADER_SIZE), adLen)\n            mstore(auth, fmp) // auth.authenticatorData = pointer to this bytes array\n\n            // Advance past authenticatorData allocation with 32-byte alignment\n            // adAlloc = 32 (length prefix) + ceil(adLen / 32) * 32\n            let adAlloc := add(0x20, and(add(adLen, 0x1f), not(0x1f)))\n            let cdPtr := add(fmp, adAlloc)\n\n            // Allocate clientDataJSON: write length prefix then copy remaining bytes\n            mstore(cdPtr, cdLen)\n            calldatacopy(add(cdPtr, 0x20), add(off, add(WEBAUTHN_AUTH_HEADER_SIZE, adLen)), cdLen)\n            mstore(add(auth, 0x20), cdPtr) // auth.clientDataJSON = pointer to this bytes array\n\n            // Update free memory pointer past both allocations with 32-byte alignment\n            mstore(0x40, add(cdPtr, add(0x20, and(add(cdLen, 0x1f), not(0x1f)))))\n        }\n\n        ok = true;\n    }\n}\n"},"src/OneAuth/lib/Constants.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\n/// @dev Maximum allowed merkle proof depth. Bounds-checks prevent DoS via oversized proofs.\n///      32 levels supports trees with up to 2^32 (~4 billion) leaves.\nuint256 constant MAX_MERKLE_DEPTH = 32;\n\n/// @dev Maximum number of credentials per account. Prevents unbounded gas costs during\n///      onUninstall iteration and limits storage growth.\nuint256 constant MAX_CREDENTIALS = 64;\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\n// Constants\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    error ModuleAlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not sufficient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n\ninterface IPolicy is IModule {\n    function checkUserOpPolicy(\n        bytes32 id,\n        PackedUserOperation calldata userOp\n    )\n        external\n        payable\n        returns (uint256);\n    function checkSignaturePolicy(\n        bytes32 id,\n        address sender,\n        bytes32 hash,\n        bytes calldata sig\n    )\n        external\n        view\n        returns (uint256);\n}\n\ninterface ISigner is IModule {\n    function checkUserOpSignature(\n        bytes32 id,\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        returns (uint256);\n    function checkSignature(\n        bytes32 id,\n        address sender,\n        bytes32 hash,\n        bytes calldata sig\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IPreValidationHookERC1271 is IModule {\n    function preValidationHookERC1271(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n\ninterface IPreValidationHookERC4337 is IModule {\n    function preValidationHookERC4337(\n        PackedUserOperation calldata userOp,\n        uint256 missingAccountFunds,\n        bytes32 userOpHash\n    )\n        external\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ModuleBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IModule as IERC7579Module } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_POLICY,\n    MODULE_TYPE_SIGNER,\n    MODULE_TYPE_STATELESS_VALIDATOR\n} from \"./utils/ERC7579Constants.sol\";\n\nabstract contract ERC7579ModuleBase is IERC7579Module {\n    uint256 internal constant TYPE_VALIDATOR = MODULE_TYPE_VALIDATOR;\n    uint256 internal constant TYPE_EXECUTOR = MODULE_TYPE_EXECUTOR;\n    uint256 internal constant TYPE_FALLBACK = MODULE_TYPE_FALLBACK;\n    uint256 internal constant TYPE_HOOK = MODULE_TYPE_HOOK;\n    uint256 internal constant TYPE_POLICY = MODULE_TYPE_POLICY;\n    uint256 internal constant TYPE_SIGNER = MODULE_TYPE_SIGNER;\n    uint256 internal constant TYPE_STATELESS_VALIDATOR = MODULE_TYPE_STATELESS_VALIDATOR;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ValidatorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {\n    PackedUserOperation,\n    _packValidationData as _packValidationData4337\n} from \"../external/ERC4337.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579ValidatorBase is ERC7579ModuleBase {\n    type ValidationData is uint256;\n\n    ValidationData internal constant VALIDATION_SUCCESS = ValidationData.wrap(0);\n    ValidationData internal constant VALIDATION_FAILED = ValidationData.wrap(1);\n    bytes4 internal constant EIP1271_SUCCESS = 0x1626ba7e;\n    bytes4 internal constant EIP1271_FAILED = 0xFFFFFFFF;\n\n    /**\n     * Helper to pack the return value for validateUserOp, when not using an aggregator.\n     * @param sigFailed  - True for signature failure, false for success.\n     * @param validUntil - Last timestamp this UserOperation is valid (or zero for\n     * infinite).\n     * @param validAfter - First timestamp this UserOperation is valid.\n     */\n    function _packValidationData(\n        bool sigFailed,\n        uint48 validUntil,\n        uint48 validAfter\n    )\n        internal\n        pure\n        returns (ValidationData)\n    {\n        return ValidationData.wrap(_packValidationData4337(sigFailed, validUntil, validAfter));\n    }\n\n    function _unpackValidationData(ValidationData _packedData)\n        internal\n        pure\n        returns (bool sigFailed, uint48 validUntil, uint48 validAfter)\n    {\n        uint256 packedData = ValidationData.unwrap(_packedData);\n        sigFailed = (packedData & 1) == 1;\n        validUntil = uint48((packedData >> 160) & ((1 << 48) - 1));\n        validAfter = uint48((packedData >> (160 + 48)) & ((1 << 48) - 1));\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        virtual\n        returns (ValidationData);\n\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        virtual\n        returns (bytes4);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579StatelessValidatorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { IStatelessValidator } from \"./interfaces/IStatelessValidator.sol\";\n\nabstract contract ERC7579StatelessValidatorBase is ERC7579ModuleBase, IStatelessValidator {\n    function validateSignatureWithData(\n        bytes32,\n        bytes calldata,\n        bytes calldata\n    )\n        external\n        view\n        virtual\n        returns (bool validSig);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579HybridValidatorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\nimport {\n    PackedUserOperation,\n    _packValidationData as _packValidationData4337\n} from \"../external/ERC4337.sol\";\nimport { ERC7579ValidatorBase } from \"./ERC7579ValidatorBase.sol\";\nimport { ERC7579StatelessValidatorBase } from \"./ERC7579StatelessValidatorBase.sol\";\n\n/// @notice Base contract for hybrid validators, which are both stateful and stateless.\nabstract contract ERC7579HybridValidatorBase is\n    ERC7579ValidatorBase,\n    ERC7579StatelessValidatorBase\n{ }\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ExecutorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IExecutor as IERC7579Executor } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { IERC7579Account } from \"../accounts/common/interfaces/IERC7579Account.sol\";\nimport {\n    Execution,\n    ExecutionLib as ERC7579ExecutionLib\n} from \"../accounts/erc7579/lib/ExecutionLib.sol\";\nimport {\n    ModeCode,\n    ModeLib as ERC7579ModeLib,\n    CALLTYPE_SINGLE,\n    EXECTYPE_DEFAULT,\n    MODE_DEFAULT,\n    ModePayload,\n    CALLTYPE_BATCH,\n    EXECTYPE_DEFAULT,\n    MODE_DEFAULT,\n    CALLTYPE_DELEGATECALL\n} from \"../accounts/common/lib/ModeLib.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579ExecutorBase is IERC7579Executor, ERC7579ModuleBase {\n    function _execute(\n        address account,\n        address to,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n        returns (bytes memory result)\n    {\n        ModeCode modeCode = ERC7579ModeLib.encode({\n            callType: CALLTYPE_SINGLE,\n            execType: EXECTYPE_DEFAULT,\n            mode: MODE_DEFAULT,\n            payload: ModePayload.wrap(bytes22(0))\n        });\n\n        return IERC7579Account(account).executeFromExecutor(\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\n        )[0];\n    }\n\n    function _execute(\n        address to,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n        returns (bytes memory result)\n    {\n        return _execute(msg.sender, to, value, data);\n    }\n\n    function _execute(\n        address account,\n        Execution[] memory execs\n    )\n        internal\n        returns (bytes[] memory results)\n    {\n        ModeCode modeCode = ERC7579ModeLib.encode({\n            callType: CALLTYPE_BATCH,\n            execType: EXECTYPE_DEFAULT,\n            mode: MODE_DEFAULT,\n            payload: ModePayload.wrap(bytes22(0))\n        });\n        results = IERC7579Account(account).executeFromExecutor(\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\n        );\n    }\n\n    function _execute(Execution[] memory execs) internal returns (bytes[] memory results) {\n        return _execute(msg.sender, execs);\n    }\n\n    // Note: Not every account will support delegatecalls\n    function _executeDelegateCall(\n        address account,\n        address delegateTarget,\n        bytes memory callData\n    )\n        internal\n        returns (bytes[] memory results)\n    {\n        ModeCode modeCode = ERC7579ModeLib.encode({\n            callType: CALLTYPE_DELEGATECALL,\n            execType: EXECTYPE_DEFAULT,\n            mode: MODE_DEFAULT,\n            payload: ModePayload.wrap(bytes22(0))\n        });\n        results = IERC7579Account(account).executeFromExecutor(\n            modeCode, abi.encodePacked(delegateTarget, callData)\n        );\n    }\n\n    // Note: Not every account will support delegatecalls\n    function _executeDelegateCall(\n        address delegateTarget,\n        bytes memory callData\n    )\n        internal\n        returns (bytes[] memory results)\n    {\n        return _executeDelegateCall(msg.sender, delegateTarget, callData);\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579HookBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IHook as IERC7579Hook } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { TrustedForwarder } from \"./utils/TrustedForwarder.sol\";\n\nabstract contract ERC7579HookBase is IERC7579Hook, ERC7579ModuleBase, TrustedForwarder {\n    /**\n     * Precheck hook\n     *\n     * @param msgSender sender of the transaction\n     * @param msgValue value of the transaction\n     * @param msgData data of the transaction\n     *\n     * @return hookData data for the postcheck hook\n     */\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        virtual\n        returns (bytes memory hookData)\n    {\n        // route to internal function\n        return _preCheck(_getAccount(), msgSender, msgValue, msgData);\n    }\n\n    /**\n     * Postcheck hook\n     *\n     * @param hookData data from the precheck hook\n     */\n    function postCheck(bytes calldata hookData) external virtual {\n        // route to internal function\n        _postCheck(_getAccount(), hookData);\n    }\n\n    /**\n     * Precheck hook\n     *\n     * @param account account of the transaction\n     * @param msgSender sender of the transaction\n     * @param msgValue value of the transaction\n     * @param msgData data of the transaction\n     *\n     * @return hookData data for the postcheck hook\n     */\n    function _preCheck(\n        address account,\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData);\n\n    /**\n     * Postcheck hook\n     *\n     * @param account account of the transaction\n     * @param hookData data from the precheck hook\n     */\n    function _postCheck(address account, bytes calldata hookData) internal virtual;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579HookDestruct.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC7579Account } from \"../accounts/common/interfaces/IERC7579Account.sol\";\nimport { IHook as IERC7579Hook } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { ExecutionLib, Execution } from \"../accounts/erc7579/lib/ExecutionLib.sol\";\nimport {\n    ModeLib,\n    CallType,\n    ModeCode,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"../accounts/common/lib/ModeLib.sol\";\nimport { IAccountExecute } from \"../external/ERC4337.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { TrustedForwarder } from \"./utils/TrustedForwarder.sol\";\n\nuint256 constant EXECUSEROP_OFFSET = 164;\nuint256 constant EXEC_OFFSET = 100;\nuint256 constant INSTALL_OFFSET = 132;\n\nabstract contract ERC7579HookDestruct is IERC7579Hook, ERC7579ModuleBase, TrustedForwarder {\n    error HookInvalidSelector();\n    error InvalidCallType();\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                CALLDATA DECODING\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        virtual\n        override\n        returns (bytes memory hookData)\n    {\n        bytes4 selector = bytes4(msgData[0:4]);\n\n        if (selector == IAccountExecute.executeUserOp.selector) {\n            uint256 offset =\n                uint256(bytes32(msgData[EXECUSEROP_OFFSET:EXECUSEROP_OFFSET + 32])) + 68;\n            uint256 paramLen = uint256(bytes32(msgData[offset:offset + 32]));\n            offset += 32;\n            bytes calldata _msgData = msgData[offset:offset + paramLen];\n            return _decodeCallData(msgSender, msgValue, _msgData);\n        } else {\n            return _decodeCallData(msgSender, msgValue, msgData);\n        }\n    }\n\n    function _decodeCallData(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        internal\n        returns (bytes memory hookData)\n    {\n        bytes4 selector = bytes4(msgData[0:4]);\n        if (selector == IERC7579Account.execute.selector) {\n            return _handle4337Executions(msgSender, msgData);\n        } else if (selector == IERC7579Account.executeFromExecutor.selector) {\n            return _handleExecutorExecutions(msgSender, msgData);\n        } else if (selector == IERC7579Account.installModule.selector) {\n            uint256 paramLen = msgData.length > INSTALL_OFFSET\n                ? uint256(bytes32(msgData[INSTALL_OFFSET - 32:INSTALL_OFFSET]))\n                : uint256(0);\n            bytes calldata initData = msgData.length > INSTALL_OFFSET\n                ? msgData[INSTALL_OFFSET:INSTALL_OFFSET + paramLen]\n                : msgData[0:0];\n            uint256 moduleType = uint256(bytes32(msgData[4:36]));\n            address module = address(bytes20((msgData[48:68])));\n            return onInstallModule(_getAccount(), msgSender, moduleType, module, initData);\n        } else if (selector == IERC7579Account.uninstallModule.selector) {\n            uint256 paramLen = msgData.length > INSTALL_OFFSET\n                ? uint256(bytes32(msgData[INSTALL_OFFSET - 32:INSTALL_OFFSET]))\n                : uint256(0);\n            bytes calldata initData = msgData.length > INSTALL_OFFSET\n                ? msgData[INSTALL_OFFSET:INSTALL_OFFSET + paramLen]\n                : msgData[0:0];\n\n            uint256 moduleType = uint256(bytes32(msgData[4:36]));\n            address module = address(bytes20((msgData[48:68])));\n\n            return onUninstallModule(_getAccount(), msgSender, moduleType, module, initData);\n        } else {\n            return onUnknownFunction(_getAccount(), msgSender, msgValue, msgData);\n        }\n    }\n\n    function _handle4337Executions(\n        address msgSender,\n        bytes calldata msgData\n    )\n        internal\n        returns (bytes memory hookData)\n    {\n        uint256 paramLen = uint256(bytes32(msgData[EXEC_OFFSET - 32:EXEC_OFFSET]));\n        bytes calldata encodedExecutions = msgData[EXEC_OFFSET:EXEC_OFFSET + paramLen];\n\n        ModeCode mode = ModeCode.wrap(bytes32(msgData[4:36]));\n        CallType calltype = ModeLib.getCallType(mode);\n\n        if (calltype == CALLTYPE_SINGLE) {\n            (address to, uint256 value, bytes calldata callData) =\n                ExecutionLib.decodeSingle(encodedExecutions);\n            return onExecute(_getAccount(), msgSender, to, value, callData);\n        } else if (calltype == CALLTYPE_BATCH) {\n            Execution[] calldata execs = ExecutionLib.decodeBatch(encodedExecutions);\n            return onExecuteBatch(_getAccount(), msgSender, execs);\n        } else if (calltype == CALLTYPE_DELEGATECALL) {\n            address to = address(bytes20(encodedExecutions[0:20]));\n            bytes calldata callData = encodedExecutions[20:];\n            return onExecuteDelegateCall(_getAccount(), msgSender, to, callData);\n        } else {\n            revert InvalidCallType();\n        }\n    }\n\n    function _handleExecutorExecutions(\n        address msgSender,\n        bytes calldata msgData\n    )\n        internal\n        returns (bytes memory hookData)\n    {\n        uint256 paramLen = uint256(bytes32(msgData[EXEC_OFFSET - 32:EXEC_OFFSET]));\n        bytes calldata encodedExecutions = msgData[EXEC_OFFSET:EXEC_OFFSET + paramLen];\n\n        ModeCode mode = ModeCode.wrap(bytes32(msgData[4:36]));\n        CallType calltype = ModeLib.getCallType(mode);\n\n        if (calltype == CALLTYPE_SINGLE) {\n            (address to, uint256 value, bytes calldata callData) =\n                ExecutionLib.decodeSingle(encodedExecutions);\n            return onExecuteFromExecutor(_getAccount(), msgSender, to, value, callData);\n        } else if (calltype == CALLTYPE_BATCH) {\n            Execution[] calldata execs = ExecutionLib.decodeBatch(encodedExecutions);\n            return onExecuteBatchFromExecutor(_getAccount(), msgSender, execs);\n        } else if (calltype == CALLTYPE_DELEGATECALL) {\n            address to = address(bytes20(encodedExecutions[0:20]));\n            bytes calldata callData = encodedExecutions[20:];\n            return onExecuteDelegateCallFromExecutor(_getAccount(), msgSender, to, callData);\n        } else {\n            revert InvalidCallType();\n        }\n    }\n\n    function postCheck(bytes calldata hookData) external virtual override {\n        onPostCheck(_getAccount(), hookData);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EXECUTION\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onExecute(\n        address account,\n        address msgSender,\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteBatch(\n        address account,\n        address msgSender,\n        Execution[] calldata\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteDelegateCall(\n        address account,\n        address msgSender,\n        address target,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteFromExecutor(\n        address account,\n        address msgSender,\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteBatchFromExecutor(\n        address account,\n        address msgSender,\n        Execution[] calldata\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteDelegateCallFromExecutor(\n        address account,\n        address msgSender,\n        address target,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONFIG\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onInstallModule(\n        address account,\n        address msgSender,\n        uint256 moduleType,\n        address module,\n        bytes calldata initData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onUninstallModule(\n        address account,\n        address msgSender,\n        uint256 moduleType,\n        address module,\n        bytes calldata deInitData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                UNKNOWN FUNCTION\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onUnknownFunction(\n        address account,\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     POSTCHECK\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onPostCheck(address account, bytes calldata hookData) internal virtual { }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579FallbackBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IFallback as IERC7579Fallback } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579FallbackBase is IERC7579Fallback, ERC7579ModuleBase {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe\n     * contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender)\n     * supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/SchedulingBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579ExecutorBase } from \"./ERC7579ExecutorBase.sol\";\n\nabstract contract SchedulingBase is ERC7579ExecutorBase {\n    /*//////////////////////////////////////////////////////////////////////////\n                            CONSTANTS & STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    error InvalidExecution();\n\n    event ExecutionAdded(address indexed smartAccount, uint256 indexed jobId);\n    event ExecutionTriggered(address indexed smartAccount, uint256 indexed jobId);\n    event ExecutionStatusUpdated(address indexed smartAccount, uint256 indexed jobId);\n    event ExecutionsCancelled(address indexed smartAccount);\n\n    mapping(address smartAccount => mapping(uint256 jobId => ExecutionConfig)) public executionLog;\n\n    mapping(address smartAccount => uint256 jobCount) public accountJobCount;\n\n    struct ExecutionConfig {\n        uint48 executeInterval;\n        uint16 numberOfExecutions;\n        uint16 numberOfExecutionsCompleted;\n        uint48 startDate;\n        bool isEnabled;\n        uint48 lastExecutionTime;\n        bytes executionData;\n    }\n\n    struct ExecutorAccess {\n        uint256 jobId;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONFIG\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _onInstall(bytes calldata packedSchedulingData) internal {\n        address account = msg.sender;\n        if (isInitialized(account)) {\n            revert ModuleAlreadyInitialized(account);\n        }\n\n        _createExecution({ orderData: packedSchedulingData });\n    }\n\n    function _onUninstall() internal {\n        address account = msg.sender;\n\n        uint256 count = accountJobCount[account];\n        for (uint256 i = 1; i <= count; i++) {\n            delete executionLog[account][i];\n        }\n        accountJobCount[account] = 0;\n\n        emit ExecutionsCancelled(account);\n    }\n\n    function isInitialized(address smartAccount) public view returns (bool) {\n        return accountJobCount[smartAccount] != 0;\n    }\n\n    function addOrder(bytes calldata orderData) external {\n        address account = msg.sender;\n        if (!isInitialized(account)) revert NotInitialized(account);\n\n        _createExecution({ orderData: orderData });\n    }\n\n    function toggleOrder(uint256 jobId) external {\n        address account = msg.sender;\n\n        ExecutionConfig storage executionConfig = executionLog[account][jobId];\n\n        if (executionConfig.numberOfExecutions == 0) {\n            revert InvalidExecution();\n        }\n\n        executionConfig.isEnabled = !executionConfig.isEnabled;\n\n        emit ExecutionStatusUpdated(account, jobId);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     INTERNAL\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _createExecution(bytes calldata orderData) internal {\n        address account = msg.sender;\n\n        uint256 jobId = accountJobCount[account] + 1;\n        accountJobCount[account]++;\n\n        // prevent user from supplying an invalid number of execution (0)\n        uint16 nrOfExecutions = uint16(bytes2(orderData[6:8]));\n        if (nrOfExecutions == 0) revert InvalidExecution();\n\n        executionLog[account][jobId] = ExecutionConfig({\n            numberOfExecutionsCompleted: 0,\n            isEnabled: true,\n            lastExecutionTime: 0,\n            executeInterval: uint48(bytes6(orderData[0:6])),\n            numberOfExecutions: nrOfExecutions,\n            startDate: uint48(bytes6(orderData[8:14])),\n            executionData: orderData[14:]\n        });\n\n        emit ExecutionAdded(account, jobId);\n    }\n\n    function _isExecutionValid(uint256 jobId) internal view {\n        ExecutionConfig storage executionConfig = executionLog[msg.sender][jobId];\n\n        if (!executionConfig.isEnabled) {\n            revert InvalidExecution();\n        }\n\n        if (executionConfig.lastExecutionTime + executionConfig.executeInterval > block.timestamp) {\n            revert InvalidExecution();\n        }\n\n        if (executionConfig.numberOfExecutionsCompleted >= executionConfig.numberOfExecutions) {\n            revert InvalidExecution();\n        }\n\n        if (executionConfig.startDate > block.timestamp) {\n            revert InvalidExecution();\n        }\n    }\n\n    modifier canExecute(uint256 jobId) {\n        _isExecutionValid(jobId);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     METADATA\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\n        return typeID == TYPE_EXECUTOR;\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7484RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\n\nabstract contract ERC7484RegistryAdapter {\n    // registry address\n    IERC7484 public immutable REGISTRY;\n\n    /**\n     * Contract constructor\n     * @dev sets the registry as an immutable variable\n     *\n     * @param _registry The registry address\n     */\n    constructor(IERC7484 _registry) {\n        // set the registry\n        REGISTRY = _registry;\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579PolicyBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { IPolicy, ConfigId } from \"./interfaces/IPolicy.sol\";\n\nabstract contract ERC7579PolicyBase is ERC7579ModuleBase, IPolicy {\n    function initializeWithMultiplexer(\n        address account,\n        ConfigId configId,\n        bytes calldata initData\n    )\n        external\n        virtual;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC1271Policy.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579PolicyBase } from \"./ERC7579PolicyBase.sol\";\nimport { ConfigId, I1271Policy } from \"./interfaces/IPolicy.sol\";\n\nabstract contract ERC1271Policy is ERC7579PolicyBase, I1271Policy {\n    function check1271SignedAction(\n        ConfigId id,\n        address requestSender,\n        address account,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        external\n        view\n        virtual\n        returns (bool);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ActionPolicy.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579PolicyBase } from \"./ERC7579PolicyBase.sol\";\nimport { ConfigId, IActionPolicy } from \"./interfaces/IPolicy.sol\";\n\nabstract contract ERC7579ActionPolicy is ERC7579PolicyBase, IActionPolicy {\n    function checkAction(\n        ConfigId id,\n        address account,\n        address target,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        virtual\n        returns (uint256);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579UserOpPolicy.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579PolicyBase } from \"./ERC7579PolicyBase.sol\";\nimport { ConfigId, IUserOpPolicy } from \"./interfaces/IPolicy.sol\";\nimport { PackedUserOperation } from \"../external/ERC4337.sol\";\n\nabstract contract ERC7579UserOpPolicy is ERC7579PolicyBase, IUserOpPolicy {\n    function checkUserOp(\n        ConfigId id,\n        PackedUserOperation calldata userOp\n    )\n        external\n        virtual\n        returns (uint256);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/utils/TrustedForwarder.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nabstract contract TrustedForwarder {\n    // account => trustedForwarder\n    mapping(address account => address trustedForwarder) public trustedForwarder;\n\n    /**\n     * Set the trusted forwarder for an account\n     *\n     * @param forwarder The address of the trusted forwarder\n     */\n    function setTrustedForwarder(address forwarder) external {\n        trustedForwarder[msg.sender] = forwarder;\n    }\n\n    /**\n     * Clear the trusted forwarder for an account\n     */\n    function clearTrustedForwarder() public {\n        trustedForwarder[msg.sender] = address(0);\n    }\n\n    /**\n     * Check if a forwarder is trusted for an account\n     *\n     * @param forwarder The address of the forwarder\n     * @param account The address of the account\n     *\n     * @return true if the forwarder is trusted for the account\n     */\n    function isTrustedForwarder(address forwarder, address account) public view returns (bool) {\n        return forwarder == trustedForwarder[account];\n    }\n\n    /**\n     * Get the sender of the transaction\n     *\n     * @return account the sender of the transaction\n     */\n    function _getAccount() internal view returns (address account) {\n        account = msg.sender;\n        address _account;\n        address forwarder;\n        if (msg.data.length >= 40) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                _account := shr(96, calldataload(sub(calldatasize(), 20)))\n                forwarder := shr(96, calldataload(sub(calldatasize(), 40)))\n            }\n            if (forwarder == msg.sender && isTrustedForwarder(forwarder, _account)) {\n                account = _account;\n            }\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/EntryPointSimulations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"./EntryPoint.sol\";\nimport \"../interfaces/IEntryPointSimulations.sol\";\n\n/*\n * This contract inherits the EntryPoint and extends it with the view-only methods that are executed by\n * the bundler in order to check UserOperation validity and estimate its gas consumption.\n * This contract should never be deployed on-chain and is only used as a parameter for the \"eth_call\" request.\n */\ncontract EntryPointSimulations is EntryPoint, IEntryPointSimulations {\n    // solhint-disable-next-line var-name-mixedcase\n    AggregatorStakeInfo private NOT_AGGREGATED = AggregatorStakeInfo(address(0), StakeInfo(0, 0));\n\n    SenderCreator private _senderCreator;\n\n    function initSenderCreator() internal virtual {\n        //this is the address of the first contract created with CREATE by this address.\n        address createdObj = address(uint160(uint256(keccak256(abi.encodePacked(hex\"d694\", address(this), hex\"01\")))));\n        _senderCreator = SenderCreator(createdObj);\n    }\n\n    function senderCreator() internal view virtual override returns (SenderCreator) {\n        // return the same senderCreator as real EntryPoint.\n        // this call is slightly (100) more expensive than EntryPoint's access to immutable member\n        return _senderCreator;\n    }\n\n    /**\n     * simulation contract should not be deployed, and specifically, accounts should not trust\n     * it as entrypoint, since the simulation functions don't check the signatures\n     */\n    constructor() {\n        require(block.number < 100, \"should not be deployed\");\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    ){\n        UserOpInfo memory outOpInfo;\n\n        _simulationOnlyValidations(userOp);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(\n            outOpInfo.mUserOp.paymaster\n        );\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20\n                ? address(bytes20(initCode[0 : 20]))\n                : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        address aggregator = address(uint160(validationData));\n        ReturnInfo memory returnInfo = ReturnInfo(\n            outOpInfo.preOpGas,\n            outOpInfo.prefund,\n            validationData,\n            paymasterValidationData,\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\n        );\n\n        AggregatorStakeInfo memory aggregatorInfo = NOT_AGGREGATED;\n        if (uint160(aggregator) != SIG_VALIDATION_SUCCESS && uint160(aggregator) != SIG_VALIDATION_FAILED) {\n            aggregatorInfo = AggregatorStakeInfo(\n                aggregator,\n                _getStakeInfo(aggregator)\n            );\n        }\n        return ValidationResult(\n            returnInfo,\n            senderInfo,\n            factoryInfo,\n            paymasterInfo,\n            aggregatorInfo\n        );\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external nonReentrant\n    returns (\n        ExecutionResult memory\n    ){\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, op, opInfo);\n\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        return ExecutionResult(\n            opInfo.preOpGas,\n            paid,\n            validationData,\n            paymasterValidationData,\n            targetSuccess,\n            targetResult\n        );\n    }\n\n    function _simulationOnlyValidations(\n        PackedUserOperation calldata userOp\n    )\n    internal\n    {\n        //initialize senderCreator(). we can't rely on constructor\n        initSenderCreator();\n\n        try\n        this._validateSenderAndPaymaster(\n            userOp.initCode,\n            userOp.sender,\n            userOp.paymasterAndData\n        )\n        // solhint-disable-next-line no-empty-blocks\n        {} catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n     * Called only during simulation.\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n     * @param initCode         - The smart account constructor code.\n     * @param sender           - The sender address.\n     * @param paymasterAndData - The paymaster address (followed by other params, ignored by this method)\n     */\n    function _validateSenderAndPaymaster(\n        bytes calldata initCode,\n        address sender,\n        bytes calldata paymasterAndData\n    ) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n            if (paymaster.code.length == 0) {\n                // It would revert anyway. but give a meaningful message.\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    //make sure depositTo cost is more than normal EntryPoint's cost,\n    // to mitigate DoS vector on the bundler\n    // empiric test showed that without this wrapper, simulation depositTo costs less..\n    function depositTo(address account) public override(IStakeManager, StakeManager) payable {\n        unchecked{\n        // silly code, to waste some gas to make sure depositTo is always little more\n        // expensive than on-chain call\n            uint256 x = 1;\n            while (x < 5) {\n                x++;\n            }\n            StakeManager.depositTo(account);\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccountExecute.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccountExecute {\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPointSimulations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IEntryPoint.sol\";\n\ninterface IEntryPointSimulations is IEntryPoint {\n    // Return value of simulateHandleOp.\n    struct ExecutionResult {\n        uint256 preOpGas;\n        uint256 paid;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bool targetSuccess;\n        bytes targetResult;\n    }\n\n    /**\n     * Successful result from simulateValidation.\n     * If the account returns a signature aggregator the \"aggregatorInfo\" struct is filled in as well.\n     * @param returnInfo     Gas and time-range returned values\n     * @param senderInfo     Stake information about the sender\n     * @param factoryInfo    Stake information about the factory (if any)\n     * @param paymasterInfo  Stake information about the paymaster (if any)\n     * @param aggregatorInfo Signature aggregation info (if the account requires signature aggregator)\n     *                       Bundler MUST use it to verify the signature, or reject the UserOperation.\n     */\n    struct ValidationResult {\n        ReturnInfo returnInfo;\n        StakeInfo senderInfo;\n        StakeInfo factoryInfo;\n        StakeInfo paymasterInfo;\n        AggregatorStakeInfo aggregatorInfo;\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage\n     *      outside the account's data.\n     * @param userOp - The user operation to validate.\n     * @return the validation result structure\n     */\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    );\n\n    /**\n     * Simulate full execution of a UserOperation (including both validation and target execution)\n     * It performs full validation of the UserOperation, but ignores signature error.\n     * An optional target address is called after the userop succeeds,\n     * and its value is returned (before the entire call is reverted).\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op The UserOperation to simulate.\n     * @param target         - If nonzero, a target address to call after userop simulation. If called,\n     *                         the targetSuccess and targetResult are set to the return from that call.\n     * @param targetCallData - CallData to pass to target address.\n     * @return the execution result structure\n     */\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external\n    returns (\n        ExecutionResult memory\n    );\n}\n"},"node_modules/solady/src/utils/Base64.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    ENCODING / DECODING                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"},"node_modules/solady/src/utils/P256.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized P256 wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/P256.sol)\n/// @author Modified from Daimo P256 Verifier (https://github.com/daimo-eth/p256-verifier/blob/master/src/P256.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/P256.sol)\nlibrary P256 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Address of the Solidity P256 verifier.\n    /// Please make sure the contract is deployed onto the chain you are working on.\n    /// See: https://gist.github.com/Vectorized/599b0d8a94d21bc74700eb1354e2f55c\n    /// Unlike RIP-7212, this verifier returns `uint256(0)` on failure, to\n    /// facilitate easier existence check. This verifier will also never revert.\n    address internal constant VERIFIER = 0x000000000000D01eA45F9eFD5c54f037Fa57Ea1a;\n\n    /// @dev The existence of this contract, as determined by non-empty bytecode,\n    /// implies the existence of the RIP-7212 precompile.\n    /// See: https://gist.github.com/Vectorized/3c69dcf4604b9e1216525cabcd06ee34\n    /// This is to enable the optimization to skip the `VERIFIER` entirely\n    /// when the `RIP_PRECOMPILE` returns empty returndata for an invalid signature.\n    address internal constant CANARY = 0x0000000000001Ab2e8006Fd8B71907bf06a5BDEE;\n\n    /// @dev Address of the RIP-7212 P256 verifier precompile.\n    /// Currently, we don't support EIP-7212's precompile at 0x0b as it has not been finalized.\n    /// See: https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md\n    address internal constant RIP_PRECOMPILE = 0x0000000000000000000000000000000000000100;\n\n    /// @dev The order of the secp256r1 elliptic curve.\n    uint256 internal constant N = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n    /// @dev `N/2`. Used for checking the malleability of the signature.\n    uint256 private constant _HALF_N =\n        0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                P256 VERIFICATION OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns if the signature (`r`, `s`) is valid for `hash` and public key (`x`, `y`).\n    /// Does NOT include the malleability check.\n    function verifySignatureAllowMalleability(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, hash)\n            mstore(add(m, 0x20), r)\n            mstore(add(m, 0x40), s)\n            mstore(add(m, 0x60), x)\n            mstore(add(m, 0x80), y)\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\n            // RIP-7212 dictates that success returns `uint256(1)`.\n            // But failure returns zero returndata, which is ambiguous.\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(CANARY)) {\n                    // The verifier will never revert when given sufficient gas.\n                    // The `invalid` upon `staticcall` failure is solely for gas estimation.\n                    if iszero(staticcall(gas(), VERIFIER, m, 0xa0, 0x00, 0x20)) { invalid() }\n                }\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure.\n                // We shall not revert even if the verifier does not exist,\n                // to allow for workflows where reverting can cause trouble.\n            }\n            isValid := eq(1, mload(0x00))\n        }\n    }\n\n    /// @dev Returns if the signature (`r`, `s`) is valid for `hash` and public key (`x`, `y`).\n    /// Includes the malleability check.\n    function verifySignature(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, hash)\n            mstore(add(m, 0x20), r)\n            mstore(add(m, 0x40), s)\n            mstore(add(m, 0x60), x)\n            mstore(add(m, 0x80), y)\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\n            // RIP-7212 dictates that success returns `uint256(1)`.\n            // But failure returns zero returndata, which is ambiguous.\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(CANARY)) {\n                    // The verifier will never revert when given sufficient gas.\n                    // The `invalid` upon `staticcall` failure is solely for gas estimation.\n                    if iszero(staticcall(gas(), VERIFIER, m, 0xa0, 0x00, 0x20)) { invalid() }\n                }\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure.\n                // We shall not revert even if the verifier does not exist,\n                // to allow for workflows where reverting can cause trouble.\n            }\n            // Optimize for happy path. Users are unlikely to pass in malleable signatures.\n            isValid := lt(gt(s, _HALF_N), eq(1, mload(0x00)))\n        }\n    }\n\n    /// @dev Returns if the RIP-7212 precompile exists.\n    function hasPrecompile() internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // These values are taken from the standard Wycheproof test vectors.\n            // https://github.com/C2SP/wycheproof/blob/aca47066256c167f0ce04d611d718cc85654341e/testvectors/ecdsa_webcrypto_test.json#L1197\n            mstore(m, 0x532eaabd9574880dbf76b9b8cc00832c20a6ec113d682299550d7a6e0f345e25) // `hash`.\n            mstore(add(m, 0x20), 0x5) // `r`.\n            mstore(add(m, 0x40), 0x1) // `s`.\n            mstore(add(m, 0x60), 0x4a03ef9f92eb268cafa601072489a56380fa0dc43171d7712813b3a19a1eb5e5) // `x`.\n            mstore(add(m, 0x80), 0x3e213e28a608ce9a2f4a17fd830c6654018a79b3e0263d91a8ba90622df6f2f0) // `y`.\n            // The `invalid` upon `staticcall` failure is solely for gas estimation.\n            if iszero(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, m, 0x20)) { invalid() }\n            result := eq(1, mload(m))\n        }\n    }\n\n    /// @dev Returns if either the RIP-7212 precompile or the verifier exists.\n    /// Since `verifySignature` is made not reverting, this function can be used to\n    /// manually implement a revert if the current chain does not have the contracts\n    /// to support secp256r1 signature recovery.\n    function hasPrecompileOrVerifier() internal view returns (bool result) {\n        result = hasPrecompile();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(or(result, extcodesize(VERIFIER))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `s` normalized to the lower half of the curve.\n    function normalized(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := xor(s, mul(xor(sub(N, s), s), gt(s, _HALF_N)))\n        }\n    }\n\n    /// @dev Helper function for `abi.decode(encoded, (bytes32, bytes32))`.\n    /// If `encoded.length < 64`, `(x, y)` will be `(0, 0)`, which is an invalid point.\n    function tryDecodePoint(bytes memory encoded) internal pure returns (bytes32 x, bytes32 y) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := gt(mload(encoded), 0x3f)\n            x := mul(mload(add(encoded, 0x20)), t)\n            y := mul(mload(add(encoded, 0x40)), t)\n        }\n    }\n\n    /// @dev Helper function for `abi.decode(encoded, (bytes32, bytes32))`.\n    /// If `encoded.length < 64`, `(x, y)` will be `(0, 0)`, which is an invalid point.\n    function tryDecodePointCalldata(bytes calldata encoded)\n        internal\n        pure\n        returns (bytes32 x, bytes32 y)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := gt(encoded.length, 0x3f)\n            x := mul(calldataload(encoded.offset), t)\n            y := mul(calldataload(add(encoded.offset, 0x20)), t)\n        }\n    }\n}\n"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\")`.\n    /// This is only used in `_hashTypedDataSansChainId`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID =\n        0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version)\")`.\n    /// This is only used in `_hashTypedDataSansChainIdAndVerifyingContract`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT =\n        0xb03948446334eb9b2196d5eb166f69b9d49403eb4a12f36de8d3f9f3cb8e15c3;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\")`.\n    /// This is only used in `_hashTypedDataSansVerifyingContract`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT =\n        0xc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID.\n    /// Included for the niche use case of cross-chain workflows.\n    function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID and verifying contract.\n    /// Included for the niche use case of cross-chain and multi-verifier workflows.\n    function _hashTypedDataSansChainIdAndVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x60)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID and verifying contract.\n    /// Included for the niche use case of multi-verifier workflows.\n    function _hashTypedDataSansVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, chainid())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/solady/src/utils/SignatureCheckerLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch mload(signature)\n                    case 64 {\n                        let vs := mload(add(signature, 0x40))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                        mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n                isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n                isValid := and(eq(mload(d), f), and(isValid, copied))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch signature.length\n                    case 64 {\n                        let vs := calldataload(add(signature.offset, 0x20))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x40, calldataload(signature.offset)) // `r`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                        calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n                mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, and(v, 0xff)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, s) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: These ERC1271 operations do NOT have an ECDSA fallback.\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n            isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n            isValid := and(eq(mload(d), f), and(isValid, copied))\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC6492 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: These ERC6492 operations now include an ECDSA fallback at the very end.\n    // The calldata variants are excluded for brevity.\n\n    /// @dev Returns whether `signature` is valid for `hash`.\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt to\n    /// deploy / prepare the `signer` smart account before doing a regular ERC1271 check.\n    /// Note: This function is NOT reentrancy safe.\n    /// The verifier must be deployed.\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\n    /// See: https://gist.github.com/Vectorized/011d6becff6e0a73e42fe100f8d7ef04\n    /// With a dedicated verifier, this function is safe to use in contracts\n    /// that have been granted special permissions.\n    function isValidERC6492SignatureNowAllowSideEffects(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                pop(\n                    call(\n                        gas(), // Remaining gas.\n                        0x0000bc370E4DC924F427d84e2f4B9Ec81626ba7E, // Non-reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                )\n                isValid := returndatasize()\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash`.\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt\n    /// to use a reverting verifier to deploy / prepare the `signer` smart account\n    /// and do a `isValidSignature` check via the reverting verifier.\n    /// Note: This function is reentrancy safe.\n    /// The reverting verifier must be deployed.\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\n    /// See: https://gist.github.com/Vectorized/846a474c855eee9e441506676800a9ad\n    function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                let willBeZeroIfRevertingVerifierExists :=\n                    call(\n                        gas(), // Remaining gas.\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/interfaces/IStatelessValidator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStatelessValidator {\n    function validateSignatureWithData(\n        bytes32 hash,\n        bytes calldata signature,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bool);\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n// Types\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\n// Structs\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/erc7579/lib/ExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { Execution } from \"../../common/interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n */\nlibrary ExecutionLib {\n    error ERC7579DecodingError();\n\n    /**\n     * @notice Decode a batch of `Execution` executionBatch from a `bytes` calldata.\n     * @dev code is copied from solady's LibERC7579.sol\n     * https://github.com/Vectorized/solady/blob/740812cedc9a1fc11e17cb3d4569744367dedf19/src/accounts/LibERC7579.sol#L146\n     *      Credits to Vectorized and the Solady Team\n     */\n    function decodeBatch(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionCalldata.offset)\n            let s := add(executionCalldata.offset, u)\n            let e := sub(add(executionCalldata.offset, executionCalldata.length), 0x20)\n            executionBatch.offset := add(s, 0x20)\n            executionBatch.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, executionBatch.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if executionBatch.length {\n                // Perform bounds checks on the decoded `executionBatch`.\n                // Loop runs out-of-gas if `executionBatch.length` is big enough to cause overflows.\n                for { let i := executionBatch.length } 1 { } {\n                    i := sub(i, 1)\n                    let p := calldataload(add(executionBatch.offset, shl(5, i)))\n                    let c := add(executionBatch.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title ModeLib\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { neqCallType as != } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction neqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    event NewTrustedAttesters();\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/interfaces/IPolicy.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n// solhint-disable no-unused-import\nimport { PackedUserOperation, _packValidationData } from \"../../external/ERC4337.sol\";\nimport {\n    IModule as IERC7579Module,\n    VALIDATION_SUCCESS,\n    VALIDATION_FAILED\n} from \"../../accounts/common/interfaces/IERC7579Module.sol\";\nimport { IERC165 } from \"forge-std/interfaces/IERC165.sol\";\n\ntype ConfigId is bytes32;\n\n/**\n * IPolicy are external contracts that enforce policies / permission on 4337/7579 executions\n * Since it's not the account calling into this contract, and check functions are called during the\n * ERC4337 validation\n * phase, IPolicy implementations MUST follow ERC4337 storage and opcode restrictions\n * A recommend storage layout to store policy related data:\n *      mapping(id   =>   msg.sender   =>   userOp.sender(account) => state)\n *                        ^ smartSession    ^ smart account (associated storage)\n */\ninterface IPolicy is IERC165, IERC7579Module {\n    function isInitialized(address account, ConfigId configId) external view returns (bool);\n    function isInitialized(\n        address account,\n        address mulitplexer,\n        ConfigId configId\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * This function may be called by the multiplexer (SmartSessions) without deinitializing first.\n     * Policies MUST overwrite the current state when this happens\n     */\n    function initializeWithMultiplexer(\n        address account,\n        ConfigId configId,\n        bytes calldata initData\n    )\n        external;\n}\n\n/**\n * IUserOpPolicy is a policy that enforces restrictions on user operations. It is called during the\n * validation phase\n * of the ERC4337 execution.\n * Use this policy to enforce restrictions on user operations (userOp.gas, Time based restrictions).\n * The checkUserOpPolicy function should return a uint256 value that represents the policy's\n * decision.\n * The policy's decision should be one of the following:\n * - VALIDATION_SUCCESS: The user operation is allowed.\n * - VALIDATION_FAILED: The user operation is not allowed.\n */\ninterface IUserOpPolicy is IPolicy {\n    function checkUserOpPolicy(\n        ConfigId id,\n        PackedUserOperation calldata userOp\n    )\n        external\n        returns (uint256);\n}\n\n/**\n * IActionPolicy is a policy that enforces restrictions on actions. It is called during the\n * validation phase\n * of the ERC4337 execution.\n * ERC7579 accounts natively support batched executions. So in one userOp, multiple actions can be\n * executed.\n * SmartSession will destruct the execution batch, and call the policy for each action, if the\n * policy is installed for\n * the actionId for the account.\n * Use this policy to enforce restrictions on individual actions (i.e. transfers, approvals, etc).\n * The checkAction function should return a uint256 value that represents the policy's decision.\n * The policy's decision should be one of the following:\n * - VALIDATION_SUCCESS: The action is allowed.\n * - VALIDATION_FAILED: The action is not allowed.\n */\ninterface IActionPolicy is IPolicy {\n    function checkAction(\n        ConfigId id,\n        address account,\n        address target,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns (uint256);\n}\n\n/**\n * I1271Policy is a policy that enforces restrictions on 1271 signed actions. It is called during an\n * ERC1271 signature\n * validation\n */\ninterface I1271Policy is IPolicy {\n    // request sender is probably protocol, so can introduce policies based on it.\n    function check1271SignedAction(\n        ConfigId id,\n        address requestSender,\n        address account,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        external\n        view\n        returns (bool);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/EntryPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IAccountExecute.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"./UserOperationLib.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/*\n * Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n * Only one instance required on each chain.\n */\n\n/// @custom:security-contact https://bounty.ethereum.org\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard, ERC165 {\n\n    using UserOperationLib for PackedUserOperation;\n\n    SenderCreator private immutable _senderCreator = new SenderCreator();\n\n    function senderCreator() internal view virtual returns (SenderCreator) {\n        return _senderCreator;\n    }\n\n    //compensate for innerHandleOps' emit message and deposit refund.\n    // allow some slack for future gas price changes.\n    uint256 private constant INNER_GAS_OVERHEAD = 10000;\n\n    // Marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n    bytes32 private constant INNER_REVERT_LOW_PREFUND = hex\"deadaa51\";\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n    uint256 private constant PENALTY_PERCENT = 10;\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // note: solidity \"type(IEntryPoint).interfaceId\" is without inherited methods but we want to check everything\n        return interfaceId == (type(IEntryPoint).interfaceId ^ type(IStakeManager).interfaceId ^ type(INonceManager).interfaceId) ||\n            interfaceId == type(IEntryPoint).interfaceId ||\n            interfaceId == type(IStakeManager).interfaceId ||\n            interfaceId == type(INonceManager).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary - The address to receive the fees.\n     * @param amount      - Amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success, ) = beneficiary.call{value: amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * Execute a user operation.\n     * @param opIndex    - Index into the opInfo array.\n     * @param userOp     - The userOp to execute.\n     * @param opInfo     - The opInfo filled by validatePrepayment for this userOp.\n     * @return collected - The total amount this userOp paid.\n     */\n    function _executeUserOp(\n        uint256 opIndex,\n        PackedUserOperation calldata userOp,\n        UserOpInfo memory opInfo\n    )\n    internal\n    returns\n    (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n        bool success;\n        {\n            uint256 saveFreePtr;\n            assembly (\"memory-safe\") {\n                saveFreePtr := mload(0x40)\n            }\n            bytes calldata callData = userOp.callData;\n            bytes memory innerCall;\n            bytes4 methodSig;\n            assembly {\n                let len := callData.length\n                if gt(len, 3) {\n                    methodSig := calldataload(callData.offset)\n                }\n            }\n            if (methodSig == IAccountExecute.executeUserOp.selector) {\n                bytes memory executeUserOp = abi.encodeCall(IAccountExecute.executeUserOp, (userOp, opInfo.userOpHash));\n                innerCall = abi.encodeCall(this.innerHandleOp, (executeUserOp, opInfo, context));\n            } else\n            {\n                innerCall = abi.encodeCall(this.innerHandleOp, (callData, opInfo, context));\n            }\n            assembly (\"memory-safe\") {\n                success := call(gas(), address(), 0, add(innerCall, 0x20), mload(innerCall), 0, 32)\n                collected := mload(0)\n                mstore(0x40, saveFreePtr)\n            }\n        }\n        if (!success) {\n            bytes32 innerRevertCode;\n            assembly (\"memory-safe\") {\n                let len := returndatasize()\n                if eq(32,len) {\n                    returndatacopy(0, 0, 32)\n                    innerRevertCode := mload(0)\n                }\n            }\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                // handleOps was called with gas limit too low. abort entire bundle.\n                //can only be caused by bundler (leaving not enough gas for inner call)\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            } else if (innerRevertCode == INNER_REVERT_LOW_PREFUND) {\n                // innerCall reverted on prefund too low. treat entire prefund as \"gas cost\"\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n                uint256 actualGasCost = opInfo.prefund;\n                emitPrefundTooLow(opInfo);\n                emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\n                collected = actualGasCost;\n            } else {\n                emit PostOpRevertReason(\n                    opInfo.userOpHash,\n                    opInfo.mUserOp.sender,\n                    opInfo.mUserOp.nonce,\n                    Exec.getReturnData(REVERT_REASON_MAX_LEN)\n                );\n\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n                collected = _postExecution(\n                    IPaymaster.PostOpMode.postOpReverted,\n                    opInfo,\n                    context,\n                    actualGas\n                );\n            }\n        }\n    }\n\n    function emitUserOperationEvent(UserOpInfo memory opInfo, bool success, uint256 actualGasCost, uint256 actualGas) internal virtual {\n        emit UserOperationEvent(\n            opInfo.userOpHash,\n            opInfo.mUserOp.sender,\n            opInfo.mUserOp.paymaster,\n            opInfo.mUserOp.nonce,\n            success,\n            actualGasCost,\n            actualGas\n        );\n    }\n\n    function emitPrefundTooLow(UserOpInfo memory opInfo) internal virtual {\n        emit UserOperationPrefundTooLow(\n            opInfo.userOpHash,\n            opInfo.mUserOp.sender,\n            opInfo.mUserOp.nonce\n        );\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) public nonReentrant {\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n        unchecked {\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[i];\n                (\n                    uint256 validationData,\n                    uint256 pmValidationData\n                ) = _validatePrepayment(i, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i,\n                    validationData,\n                    pmValidationData,\n                    address(0)\n                );\n            }\n\n            uint256 collected = 0;\n            emit BeforeExecution();\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\n            }\n\n            _compensate(beneficiary, collected);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public nonReentrant {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(\n                address(aggregator) != address(1),\n                \"AA96 invalid aggregator\"\n            );\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {} catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (\n                    uint256 validationData,\n                    uint256 paymasterValidationData\n                ) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i,\n                    validationData,\n                    paymasterValidationData,\n                    address(aggregator)\n                );\n                opIndex++;\n            }\n        }\n\n        emit BeforeExecution();\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            PackedUserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /**\n     * A memory copy of UserOp static fields only.\n     * Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n     */\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 verificationGasLimit;\n        uint256 callGasLimit;\n        uint256 paymasterVerificationGasLimit;\n        uint256 paymasterPostOpGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * Inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     * @param callData - The callData to execute.\n     * @param opInfo   - The UserOpInfo struct.\n     * @param context  - The context bytes.\n     * @return actualGasCost - the actual cost in eth this UserOperation paid for gas\n     */\n    function innerHandleOp(\n        bytes memory callData,\n        UserOpInfo memory opInfo,\n        bytes calldata context\n    ) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint256 callGasLimit = mUserOp.callGasLimit;\n        unchecked {\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (\n                gasleft() * 63 / 64 <\n                callGasLimit +\n                mUserOp.paymasterPostOpGasLimit +\n                INNER_GAS_OVERHEAD\n            ) {\n                assembly (\"memory-safe\") {\n                    mstore(0, INNER_OUT_OF_GAS)\n                    revert(0, 32)\n                }\n            }\n        }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(\n                        opInfo.userOpHash,\n                        mUserOp.sender,\n                        mUserOp.nonce,\n                        result\n                    );\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n        unchecked {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            return _postExecution(mode, opInfo, context, actualGas);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) public view returns (bytes32) {\n        return\n            keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * Copy general fields from userOp into the memory opInfo structure.\n     * @param userOp  - The user operation.\n     * @param mUserOp - The memory user operation.\n     */\n    function _copyUserOpToMemory(\n        PackedUserOperation calldata userOp,\n        MemoryUserOp memory mUserOp\n    ) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        (mUserOp.verificationGasLimit, mUserOp.callGasLimit) = UserOperationLib.unpackUints(userOp.accountGasLimits);\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        (mUserOp.maxPriorityFeePerGas, mUserOp.maxFeePerGas) = UserOperationLib.unpackUints(userOp.gasFees);\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(\n                paymasterAndData.length >= UserOperationLib.PAYMASTER_DATA_OFFSET,\n                \"AA93 invalid paymasterAndData\"\n            );\n            (mUserOp.paymaster, mUserOp.paymasterVerificationGasLimit, mUserOp.paymasterPostOpGasLimit) = UserOperationLib.unpackPaymasterStaticFields(paymasterAndData);\n        } else {\n            mUserOp.paymaster = address(0);\n            mUserOp.paymasterVerificationGasLimit = 0;\n            mUserOp.paymasterPostOpGasLimit = 0;\n        }\n    }\n\n    /**\n     * Get the required prefunded gas fee amount for an operation.\n     * @param mUserOp - The user operation in memory.\n     */\n    function _getRequiredPrefund(\n        MemoryUserOp memory mUserOp\n    ) internal pure returns (uint256 requiredPrefund) {\n        unchecked {\n            uint256 requiredGas = mUserOp.verificationGasLimit +\n                mUserOp.callGasLimit +\n                mUserOp.paymasterVerificationGasLimit +\n                mUserOp.paymasterPostOpGasLimit +\n                mUserOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n        }\n    }\n\n    /**\n     * Create sender smart contract account if init code is provided.\n     * @param opIndex  - The operation index.\n     * @param opInfo   - The operation info.\n     * @param initCode - The init code for the smart contract account.\n     */\n    function _createSenderIfNeeded(\n        uint256 opIndex,\n        UserOpInfo memory opInfo,\n        bytes calldata initCode\n    ) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0)\n                revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            address sender1 = senderCreator().createSender{\n                gas: opInfo.mUserOp.verificationGasLimit\n            }(initCode);\n            if (sender1 == address(0))\n                revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            if (sender1 != sender)\n                revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0)\n                revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0:20]));\n            emit AccountDeployed(\n                opInfo.userOpHash,\n                sender,\n                factory,\n                opInfo.mUserOp.paymaster\n            );\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator().createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    /**\n     * Call account.validateUserOp.\n     * Revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * Decrement account's deposit if needed.\n     * @param opIndex         - The operation index.\n     * @param op              - The user operation.\n     * @param opInfo          - The operation info.\n     * @param requiredPrefund - The required prefund amount.\n     */\n    function _validateAccountPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPrefund,\n        uint256 verificationGasLimit\n    )\n        internal\n        returns (\n            uint256 validationData\n        )\n    {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address sender = mUserOp.sender;\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n            address paymaster = mUserOp.paymaster;\n            uint256 missingAccountFunds = 0;\n            if (paymaster == address(0)) {\n                uint256 bal = balanceOf(sender);\n                missingAccountFunds = bal > requiredPrefund\n                    ? 0\n                    : requiredPrefund - bal;\n            }\n            try\n                IAccount(sender).validateUserOp{\n                    gas: verificationGasLimit\n                }(op, opInfo.userOpHash, missingAccountFunds)\n            returns (uint256 _validationData) {\n                validationData = _validationData;\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA23 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (paymaster == address(0)) {\n                DepositInfo storage senderInfo = deposits[sender];\n                uint256 deposit = senderInfo.deposit;\n                if (requiredPrefund > deposit) {\n                    revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\n                }\n                senderInfo.deposit = deposit - requiredPrefund;\n            }\n        }\n    }\n\n    /**\n     * In case the request has a paymaster:\n     *  - Validate paymaster has enough deposit.\n     *  - Call paymaster.validatePaymasterUserOp.\n     *  - Revert with proper FailedOp in case paymaster reverts.\n     *  - Decrement paymaster's deposit.\n     * @param opIndex                            - The operation index.\n     * @param op                                 - The user operation.\n     * @param opInfo                             - The operation info.\n     * @param requiredPreFund                    - The required prefund amount.\n     */\n    function _validatePaymasterPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPreFund\n    ) internal returns (bytes memory context, uint256 validationData) {\n        unchecked {\n            uint256 preGas = gasleft();\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address paymaster = mUserOp.paymaster;\n            DepositInfo storage paymasterInfo = deposits[paymaster];\n            uint256 deposit = paymasterInfo.deposit;\n            if (deposit < requiredPreFund) {\n                revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\n            }\n            paymasterInfo.deposit = deposit - requiredPreFund;\n            uint256 pmVerificationGasLimit = mUserOp.paymasterVerificationGasLimit;\n            try\n                IPaymaster(paymaster).validatePaymasterUserOp{gas: pmVerificationGasLimit}(\n                    op,\n                    opInfo.userOpHash,\n                    requiredPreFund\n                )\n            returns (bytes memory _context, uint256 _validationData) {\n                context = _context;\n                validationData = _validationData;\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA33 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (preGas - gasleft() > pmVerificationGasLimit) {\n                revert FailedOp(opIndex, \"AA36 over paymasterVerificationGasLimit\");\n            }\n        }\n    }\n\n    /**\n     * Revert if either account validationData or paymaster validationData is expired.\n     * @param opIndex                 - The operation index.\n     * @param validationData          - The account validationData.\n     * @param paymasterValidationData - The paymaster validationData.\n     * @param expectedAggregator      - The expected aggregator.\n     */\n    function _validateAccountAndPaymasterValidationData(\n        uint256 opIndex,\n        uint256 validationData,\n        uint256 paymasterValidationData,\n        address expectedAggregator\n    ) internal view {\n        (address aggregator, bool outOfTimeRange) = _getValidationData(\n            validationData\n        );\n        if (expectedAggregator != aggregator) {\n            revert FailedOp(opIndex, \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\n        }\n        // pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n        // Non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation).\n        address pmAggregator;\n        (pmAggregator, outOfTimeRange) = _getValidationData(\n            paymasterValidationData\n        );\n        if (pmAggregator != address(0)) {\n            revert FailedOp(opIndex, \"AA34 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\n        }\n    }\n\n    /**\n     * Parse validationData into its components.\n     * @param validationData - The packed validation data (sigFailed, validAfter, validUntil).\n     * @return aggregator the aggregator of the validationData\n     * @return outOfTimeRange true if current time is outside the time range of this validationData.\n     */\n    function _getValidationData(\n        uint256 validationData\n    ) internal view returns (address aggregator, bool outOfTimeRange) {\n        if (validationData == 0) {\n            return (address(0), false);\n        }\n        ValidationData memory data = _parseValidationData(validationData);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n        aggregator = data.aggregator;\n    }\n\n    /**\n     * Validate account and paymaster (if defined) and\n     * also make sure total validation doesn't exceed verificationGasLimit.\n     * This method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex - The index of this userOp into the \"opInfos\" array.\n     * @param userOp  - The userOp to validate.\n     */\n    function _validatePrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata userOp,\n        UserOpInfo memory outOpInfo\n    )\n        internal\n        returns (uint256 validationData, uint256 paymasterValidationData)\n    {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // Validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow.\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        uint256 maxGasValues = mUserOp.preVerificationGas |\n            verificationGasLimit |\n            mUserOp.callGasLimit |\n            mUserOp.paymasterVerificationGasLimit |\n            mUserOp.paymasterPostOpGasLimit |\n            mUserOp.maxFeePerGas |\n            mUserOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\n        validationData = _validateAccountPrepayment(\n            opIndex,\n            userOp,\n            outOpInfo,\n            requiredPreFund,\n            verificationGasLimit\n        );\n\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\n        }\n\n        unchecked {\n            if (preGas - gasleft() > verificationGasLimit) {\n                revert FailedOp(opIndex, \"AA26 over verificationGasLimit\");\n            }\n        }\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(\n                opIndex,\n                userOp,\n                outOpInfo,\n                requiredPreFund\n            );\n        }\n        unchecked {\n            outOpInfo.prefund = requiredPreFund;\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        }\n    }\n\n    /**\n     * Process post-operation, called just after the callData is executed.\n     * If a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * The excess amount is refunded to the account (or paymaster - if it was used in the request).\n     * @param mode      - Whether is called from innerHandleOp, or outside (postOpReverted).\n     * @param opInfo    - UserOp fields and info collected during validation.\n     * @param context   - The context returned in validatePaymasterUserOp.\n     * @param actualGas - The gas used so far by this user operation.\n     */\n    function _postExecution(\n        IPaymaster.PostOpMode mode,\n        UserOpInfo memory opInfo,\n        bytes memory context,\n        uint256 actualGas\n    ) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        unchecked {\n            address refundAddress;\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n            address paymaster = mUserOp.paymaster;\n            if (paymaster == address(0)) {\n                refundAddress = mUserOp.sender;\n            } else {\n                refundAddress = paymaster;\n                if (context.length > 0) {\n                    actualGasCost = actualGas * gasPrice;\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                        try IPaymaster(paymaster).postOp{\n                            gas: mUserOp.paymasterPostOpGasLimit\n                        }(mode, context, actualGasCost, gasPrice)\n                        // solhint-disable-next-line no-empty-blocks\n                        {} catch {\n                            bytes memory reason = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                            revert PostOpReverted(reason);\n                        }\n                    }\n                }\n            }\n            actualGas += preGas - gasleft();\n\n            // Calculating a penalty for unused execution gas\n            {\n                uint256 executionGasLimit = mUserOp.callGasLimit + mUserOp.paymasterPostOpGasLimit;\n                uint256 executionGasUsed = actualGas - opInfo.preOpGas;\n                // this check is required for the gas used within EntryPoint and not covered by explicit gas limits\n                if (executionGasLimit > executionGasUsed) {\n                    uint256 unusedGas = executionGasLimit - executionGasUsed;\n                    uint256 unusedGasPenalty = (unusedGas * PENALTY_PERCENT) / 100;\n                    actualGas += unusedGasPenalty;\n                }\n            }\n\n            actualGasCost = actualGas * gasPrice;\n            uint256 prefund = opInfo.prefund;\n            if (prefund < actualGasCost) {\n                if (mode == IPaymaster.PostOpMode.postOpReverted) {\n                    actualGasCost = prefund;\n                    emitPrefundTooLow(opInfo);\n                    emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\n                } else {\n                    assembly (\"memory-safe\") {\n                        mstore(0, INNER_REVERT_LOW_PREFUND)\n                        revert(0, 32)\n                    }\n                }\n            } else {\n                uint256 refund = prefund - actualGasCost;\n                _incrementDeposit(refundAddress, refund);\n                bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n                emitUserOperationEvent(opInfo, success, actualGasCost, actualGas);\n            }\n        } // unchecked\n    }\n\n    /**\n     * The gas price this UserOp agrees to pay.\n     * Relayer/block builder might submit the TX with higher priorityFee, but the user should not.\n     * @param mUserOp - The userOp to get the gas price from.\n     */\n    function getUserOpGasPrice(\n        MemoryUserOp memory mUserOp\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * The offset of the given bytes in memory.\n     * @param data - The bytes to get the offset of.\n     */\n    function getOffsetOfMemoryBytes(\n        bytes memory data\n    ) internal pure returns (uint256 offset) {\n        assembly {\n            offset := data\n        }\n    }\n\n    /**\n     * The bytes in memory at the given offset.\n     * @param offset - The offset to get the bytes from.\n     */\n    function getMemoryBytesFromOffset(\n        uint256 offset\n    ) internal pure returns (bytes memory data) {\n        assembly (\"memory-safe\") {\n            data := offset\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function delegateAndRevert(address target, bytes calldata data) external {\n        (bool success, bytes memory ret) = target.delegatecall(data);\n        revert DelegateAndRevert(success, ret);\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"node_modules/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IPaymaster.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                                    other values are invalid for paymaster.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/utils/Exec.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\n// solhint-disable no-inline-assembly\n\n/**\n * Utility functions helpful when making different kinds of contract calls in Solidity.\n */\nlibrary Exec {\n\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\n        assembly (\"memory-safe\") {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\n        bool success = call(to,0,data,gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/StakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.23;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(\n        address account\n    ) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    /**\n     * Internal method to return just the stake info.\n     * @param addr - The account to query.\n     */\n    function _getStakeInfo(\n        address addr\n    ) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// @inheritdoc IStakeManager\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    /**\n     * Increments an account's deposit.\n     * @param account - The account to increment.\n     * @param amount  - The amount to increment by.\n     * @return the updated deposit of this account\n     */\n    function _incrementDeposit(address account, uint256 amount) internal returns (uint256) {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        info.deposit = newAmount;\n        return newAmount;\n    }\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) public virtual payable {\n        uint256 newDeposit = _incrementDeposit(account, msg.value);\n        emit Deposited(account, newDeposit);\n    }\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(\n            unstakeDelaySec >= info.unstakeDelaySec,\n            \"cannot decrease unstake time\"\n        );\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(\n            info.withdrawTime <= block.timestamp,\n            \"Stake withdrawal is not due\"\n        );\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value: stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = info.deposit - withdrawAmount;\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value: withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/SenderCreator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/**\n * Helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n    /**\n     * Call the \"initCode\" factory to create and return the sender account address.\n     * @param initCode - The initCode value from a UserOp. contains 20 bytes of factory address,\n     *                   followed by calldata.\n     * @return sender  - The returned address of the created account, or zero address on failure.\n     */\n    function createSender(\n        bytes calldata initCode\n    ) external returns (address sender) {\n        address factory = address(bytes20(initCode[0:20]));\n        bytes memory initCallData = initCode[20:];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly (\"memory-safe\") {\n            success := call(\n                gas(),\n                factory,\n                0,\n                add(initCallData, 0x20),\n                mload(initCallData),\n                0,\n                32\n            )\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/NonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport \"../interfaces/INonceManager.sol\";\n\n/**\n * nonce management functionality\n */\nabstract contract NonceManager is INonceManager {\n\n    /**\n     * The next valid sequence number for a given nonce key.\n     */\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\n\n    /// @inheritdoc INonceManager\n    function getNonce(address sender, uint192 key)\n    public view override returns (uint256 nonce) {\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n    }\n\n    // allow an account to manually increment its own nonce.\n    // (mainly so that during construction nonce can be made non-zero,\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\n    // not to 2nd transaction)\n    function incrementNonce(uint192 key) public override {\n        nonceSequenceNumber[msg.sender][key]++;\n    }\n\n    /**\n     * validate nonce uniqueness for this account.\n     * called just after validateUserOp()\n     * @return true if the nonce was incremented successfully.\n     *         false if the current nonce doesn't match the given one.\n     */\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\n\n        uint192 key = uint192(nonce >> 64);\n        uint64 seq = uint64(nonce);\n        return nonceSequenceNumber[sender][key]++ == seq;\n    }\n\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}},"settings":{"remappings":["@rhinestone/=node_modules/@rhinestone/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","modulekit/=node_modules/@rhinestone/modulekit/src/","checknsignatures/=node_modules/@rhinestone/checknsignatures/src/","flatbytes/=node_modules/@rhinestone/flatbytes/src/","@ERC4337/=node_modules/@ERC4337/","account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/","@openzeppelin/=node_modules/@openzeppelin/","@safe-global/=node_modules/@safe-global/","ds-test/=node_modules/ds-test/src/","forge-std/=node_modules/forge-std/src/","solady/=node_modules/solady/src/","solarray/=node_modules/solarray/src/","@prb/math/=node_modules/@prb/math/src/","solmate/=node_modules/solmate/src/","ExcessivelySafeCall/=node_modules/excessively-safe-call/src/","@webauthn/=node_modules/webauthn-sol/src/","@erc7579/enumerablemap4337/=node_modules/@erc7579/enumerablemap4337/src/","FreshCryptoLib/=node_modules/FreshCryptoLib/solidity/src/","node_modules/webauthn-sol/src/:openzeppelin-contracts/=node_modules/@openzeppelin/","excessively-safe-call/=node_modules/excessively-safe-call/","webauthn-sol/=node_modules/webauthn-sol/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
